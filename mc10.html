<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>TaskCo</title>
    <!-- Font Awesome for icons -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <!-- Google Fonts: Roboto, Londrina Shadow, Monoton -->
    <link
        href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500;700&family=Londrina+Shadow&family=Monoton&family=Poppins:wght@300;400;500;600;700&display=swap"
        rel="stylesheet" />
    <!-- Dexie for IndexedDB -->
    <script src="https://unpkg.com/dexie@latest/dist/dexie.js"></script>
    <!-- EasyMDE for Markdown Editing -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/easymde/dist/easymde.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/easymde/dist/easymde.min.js"></script>

    <style>
        /* ================= Global Box-Sizing ================= */
        *,
        *::before,
        *::after {
            box-sizing: border-box;
        }

        :root {
            /* Light mode colors */
            --bg-color-light: #f8f9fa;
            --bg-secondary-light: #ffffff;
            --text-color-light: #212529;
            --text-muted-light: #6c757d;
            --border-color-light: #dee2e6;
            --hover-color-light: #e9ecef;
            
            /* Dark mode colors */
            --bg-color-dark: #121212;
            --bg-secondary-dark: #1e1e1e;
            --text-color-dark: #f1f1f1;
            --text-muted-dark: #adb5bd;
            --border-color-dark: #343a40;
            --hover-color-dark: #2d2d2d;

            /* Accent colors */
            --accent-color: #ffd700;
            --accent-dark: #e6c200;
            --accent-light: #fff2ac;
            
            /* Status colors */
            --status-scoping: #17a2b8;
            --status-in-progress: #fd7e14;
            --status-completed: #28a745;
            --status-pending: #dc3545;
            
            /* Priority colors */
            --priority-high: #dc3545;
            --priority-medium: #fd7e14;
            --priority-low: #28a745;
            --priority-none: #6c757d;
            
            /* Dimensions */
            --radius: 8px;
            --transition-speed: 0.3s;
            --shadow-sm: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24);
            --shadow-md: 0 4px 6px rgba(0,0,0,0.1), 0 1px 3px rgba(0,0,0,0.08);
            --shadow-lg: 0 10px 20px rgba(0,0,0,0.1), 0 3px 6px rgba(0,0,0,0.05);
            
            /* Color palette */
            --color-1: #000000;
            --color-2: #ff4713;
            --color-3: #00573C;
            --color-4: #c80058;
            --color-5: #6E3FA3;
            --color-6: #F2A900;
            --color-7: #1E90E2;
            --color-8: #2f4f4f;
            --color-9: #ff00ff;
            --color-10: #00ffff;
        }

        body {
            margin: 0;
            padding: 0;
            font-family: "Poppins", "Roboto", sans-serif;
            background-color: var(--bg-color-light);
            color: var(--text-color-light);
            transition: background-color var(--transition-speed), color var(--transition-speed);
            line-height: 1.6;
        }

        body.dark-mode {
            background-color: var(--bg-color-dark);
            color: var(--text-color-dark);
        }

        /* ================= Scrollbar Styling ================= */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }

        ::-webkit-scrollbar-track {
            background: transparent;
        }

        ::-webkit-scrollbar-thumb {
            background-color: rgba(0, 0, 0, 0.2);
            border-radius: 10px;
        }

        body.dark-mode ::-webkit-scrollbar-thumb {
            background-color: rgba(255, 255, 255, 0.2);
        }

        ::-webkit-scrollbar-thumb:hover {
            background-color: rgba(0, 0, 0, 0.3);
        }

        body.dark-mode ::-webkit-scrollbar-thumb:hover {
            background-color: rgba(255, 255, 255, 0.3);
        }

        /* ================= Layout ================= */
        .container {
            max-width: 1600px;
            margin: 0 auto;
            padding: 20px;
        }

        .main-content {
            padding-top: 20px;
        }

        /* ================= Header & Branding ================= */
        .app-header {
            position: sticky;
            top: 0;
            z-index: 100;
            background-color: var(--bg-secondary-light);
            box-shadow: var(--shadow-sm);
            padding: 15px;
            transition: background-color var(--transition-speed);
        }

        body.dark-mode .app-header {
            background-color: var(--bg-secondary-dark);
        }

        .header-bar {
            display: grid;
            grid-template-columns: 1fr auto 1fr;
            align-items: center;
            gap: 20px;
        }

        .branding {
            grid-column: 2;
            justify-self: center;
            background: #000;
            border: 4px solid var(--accent-color);
            border-radius: 20px;
            display: inline-block;
            transform: rotate(-2deg);
            box-shadow: 0 0 20px var(--accent-color), 10px 10px 20px rgba(0, 0, 0, 0.6);
            text-align: center;
            position: relative;
            min-width: fit-content;
            padding: 20px;
        }

        .branding::before {
            content: "";
            position: absolute;
            top: -10px;
            left: -10px;
            right: -10px;
            bottom: -10px;
            z-index: -1;
            border-radius: 25px;
            background: linear-gradient(45deg, rgba(255, 255, 255, 0.1), transparent);
            filter: blur(5px);
        }

        .branding h1 {
            font-family: "Londrina Shadow", serif;
            font-size: 22px;
            color: var(--accent-color);
            text-shadow: 0 0 10px var(--accent-color), 0 0 20px var(--accent-color), 0 0 30px var(--accent-color),
                0 0 40px var(--accent-color), 0 0 50px var(--accent-color);
            margin: 0;
            line-height: 1;
            animation: neon-glow 1.5s ease-in-out infinite alternate, flicker 5s ease-in-out infinite;
        }

        .branding h2 {
            font-family: "Montserrat", sans-serif;
            font-size: 14px;
            font-weight: 700;
            color: var(--accent-color);
            -webkit-text-stroke: 1px #000;
            margin: 15px 0 0 0;
            line-height: 1;
            animation: neon-glow 1.5s ease-in-out 0.5s infinite alternate, flicker 7s ease-in-out infinite;
        }

        @keyframes neon-glow {
            from {
                text-shadow: 0 0 10px rgba(255, 255, 255, 0.1), 0 0 20px rgba(255, 255, 255, 0.2),
                    0 0 30px rgba(255, 255, 255, 0.3);
            }

            to {
                text-shadow: 0 0 20px rgba(255, 255, 255, 0.5), 0 0 30px rgba(255, 255, 255, 0.6),
                    0 0 40px rgba(255, 255, 255, 0.7);
            }
        }

        @keyframes flicker {
            0%,
            18%,
            22%,
            25%,
            53%,
            57%,
            100% {
                text-shadow: none;
            }

            20%,
            24%,
            55% {
                text-shadow: 0 0 10px rgba(255, 255, 255, 1), 0 0 20px rgba(255, 255, 255, 0.8),
                    0 0 30px rgba(255, 255, 255, 0.6);
            }
        }

        /* ================= Header Controls ================= */
        .header-controls {
            grid-column: 1;
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .header-controls input[type="text"] {
            padding: 10px 15px;
            border: 1px solid var(--border-color-light);
            border-radius: var(--radius);
            font-size: 0.95em;
            width: 280px;
            background-color: var(--bg-color-light);
            color: var (--text-color-light);
        }

        body.dark-mode .header-controls input[type="text"] {
            background-color: var(--bg-color-dark);
            color: var(--text-color-dark);
            border-color: var(--border-color-dark);
        }

        .header-btn {
            padding: 8px 16px;  /* Increased from 8px 16px */
            background: none;
            border: none;
            color: var(--text-color-light);
            font-size: 1.1em;    /* Increased from 0.9em */
            cursor: pointer;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px; 
            white-space: nowrap;
            border-radius: var(--radius);
            font-weight: 500;    /* Added for better visibility */
        }

        body.dark-mode .header-btn {
            color: var(--text-color-dark);
        }

        .header-btn.active, .header-btn:active {
            background-color: var(--accent-color);
            color: #000 !important; 
            font-weight: 500;
        }

        .header-btn:hover {
            background-color: var(--accent-color);
            color: #000 !important;
            transform: translateY(-2px);
            box-shadow: var(--shadow-sm);
        }

        .header-btn i {
            font-size: 1em;
        }

        /* ================= Controls Bar ================= */
        .controls-bar {
            display: flex;
            flex-wrap: wrap;
            justify-content: space-between;
            align-items: center;
            margin: 20px 0;
            gap: 15px;
            background-color: var(--bg-secondary-light);
            padding: 15px;
            border-radius: var(--radius);
            box-shadow: var(--shadow-sm);

            position: sticky;
            top: 125px;
            z-index: 500;
        }

        body.dark-mode .controls-bar {
            background-color: var(--bg-secondary-dark);
        }

        .left-filters {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            flex: 3;
        }
        
        .right-offset-controls {
            display: flex;
            flex-wrap: wrap;
            align-items: center;
            gap: 10px;
            flex: 1;
            justify-content: flex-end;
        }

        .filter-select {
            padding: 8px 15px;
            border: 1px solid var (--border-color-light);
            border-radius: var(--radius);
            background-color: var(--bg-color-light);
            color: var (--text-color-light);
            font-size: 0.9em;
            cursor: pointer;
        }

        body.dark-mode .filter-select {
            background-color: #000;
            color: #fff;
            border-color: var(--border-color-dark);
        }

        .view-mode-container {
            display: flex;
            justify-content: center;
        }

        .view-mode-toggle {
            display: flex;
            background-color: var(--bg-color-light);
            border-radius: var(--radius);
            overflow: hidden;
            border: 1px solid var(--border-color-light);
        }

        body.dark-mode .view-mode-toggle {
            background-color: var(--bg-color-dark);
            border-color: var(--border-color-dark);
        }

        .view-mode-btn {
            padding: 8px 16px;
            background: none;
            border: none;
            color: var(--text-color-light);
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        body.dark-mode .view-mode-btn {
            color: var(--text-color-dark);
        }

        .view-mode-btn.active {
            background-color: var(--accent-color);
            color: #000 !important; 
            font-weight: 500;
        }

        .view-mode-btn:hover:not(.active) {
            background-color: var(--hover-color-light);
        }

        body.dark-mode .view-mode-btn:hover:not(.active) {
            background-color: var(--hover-color-dark);
        }

        .right-controls {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .right-controls button {
            background: transparent;
            border: 1px solid var (--border-color-light);
            color: var(--text-color-light);
            border-radius: var (--radius);
            padding: 8px 15px;
            cursor: pointer;
            font-size: 0.9em;
            transition: all 0.2s ease;
        }

        body.dark-mode .right-controls button {
            border-color: var(--border-color-dark);
            color: var(--text-color-dark);
        }

        .right-controls button:hover {
            background-color: var(--accent-color);
            color: #000;
        }

        /* ================= Board & Columns ================= */
        .board {
            display: flex;
            gap: 15px;
            overflow-x: auto;
            padding-bottom: 15px;
            min-height: calc(100vh - 280px);
        }

        .column {
            flex: 0 0 300px;
            background-color: var(--bg-secondary-light);
            border-radius: var(--radius);
            padding: 15px;
            box-shadow: var(--shadow-sm);
            display: flex;
            flex-direction: column;
            max-height: calc(100vh - 280px);
        }

        body.dark-mode .column {
            background-color: var(--bg-secondary-dark);
        }

        .column-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 12px;
            border-bottom: 2px solid var(--border-color-light);
            margin-bottom: 15px;
        }

        body.dark-mode .column-header {
            border-color: var(--border-color-dark);
        }

        .column-title {
            font-size: 1.1em;
            font-weight: 600;
            margin: 0;
        }

        .date-label {
            font-size: 0.85em;
            color: var(--text-muted-light);
            margin-top: 5px;
        }

        body.dark-mode .date-label {
            color: var(--text-muted-dark);
        }

        .add-task-btn {
            background: none;
            border: none;
            color: var(--text-color-light);
            font-size: 1.2em;
            cursor: pointer;
            transition: transform 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            width: 30px;
            height: 30px;
        }

        body.dark-mode .add-task-btn {
            color: var(--text-color-dark); /* White in dark mode */
        }

        .add-task-btn:hover {
            transform: scale(1.2);
            color: var(--accent-color);
        }

        .column-content {
            flex: 1;
            overflow-y: auto;
            padding-right: 5px;
        }

        .drop-zone {
            height: 10px;
            margin: 5px 0;
            border-radius: var(--radius);
            transition: all 0.2s;
            position: relative;
            z-index: 5;
        }

        .drop-zone-highlight {
            background-color: rgba(255, 215, 0, 0.5);
            border: 2px dashed var(--accent-color);
            height: 60px;
        }
        
        /* Style to highlight column drag target without excessive color */
        .column-drag-over {
            box-shadow: 0 0 0 2px var(--accent-color);
        }

        /* ================= Task Card ================= */
        .task {
            position: relative;
            background-color: var(--bg-color-light);
            color: var(--text-color-light);
            border-left: 5px solid var(--color-1);
            border-radius: var(--radius);
            padding: 15px;
            margin-bottom: 15px;
            cursor: grab;
            box-shadow: var(--shadow-sm);
            transition: transform 0.3s, box-shadow 0.3s;
            user-select: none;
            z-index: 10;
        }

        body.dark-mode .task {
            background-color: var(--bg-color-dark);
            color: var(--text-color-dark);
        }

        .task:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-md);
        }

        .task.highlight {
            outline: 2px dashed var(--accent-color);
            outline-offset: 2px;
        }
        
        .task.dragging {
            opacity: 0.6;
            transform: scale(1.05);
            box-shadow: var(--shadow-lg);
        }

        .task-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 10px;
        }

        .task-title-wrapper {
            flex: 1;
            margin-right: 10px;
        }

        .task-title {
            font-weight: 600;
            font-size: 1em;
            color: inherit;
            border: none;
            background: transparent;
            padding: 0;
            width: 100%;
            margin: 0;
        }

        .task-title:focus {
            outline: none;
            border-bottom: 1px dashed var(--text-color-light);
        }

        body.dark-mode .task-title:focus {
            border-bottom-color: var(--text-color-dark);
        }

        .task-controls {
            display: flex;
            gap: 5px;
        }

        .task-control-btn {
            background: transparent;
            border: none;
            color: var(--text-muted-light);
            padding: 4px;
            font-size: 0.9em;
            cursor: pointer;
            transition: all 0.2s;
        }

        body.dark-mode .task-control-btn {
            color: var(--text-muted-dark);
        }

        .task-control-btn:hover {
            color: var(--accent-color);
            transform: scale(1.2);
        }

        /* Status badge */
        .status-badge {
            display: inline-block;
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 0.75em;
            font-weight: 500;
            margin-top: 5px;
            color: white;
        }

        .status-scoping {
            background-color: var(--status-scoping);
        }

        .status-in-progress {
            background-color: var(--status-in-progress);
        }

        .status-completed {
            background-color: var(--status-completed);
        }

        .status-pending {
            background-color: var(--status-pending);
        }

        /* Priority flag */
        .priority-flag {
            position: absolute;
            top: 5px;
            right: 5px;
            font-size: 0.8em;
        }

        .priority-high {
            color: var(--priority-high);
        }

        .priority-medium {
            color: var(--priority-medium);
        }

        .priority-low {
            color: var(--priority-low);
        }

        /* Task meta info */
        .task-meta {
            display: flex;
            flex-wrap: wrap;
            gap: 10px;
            margin-top: 10px;
            font-size: 0.85em;
            color: var(--text-muted-light);
        }

        body.dark-mode .task-meta {
            color: var(--text-muted-dark);
        }

        .task-meta-item {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .task-meta-item i {
            font-size: 0.9em;
        }

        /* Chip/Tag styling */
        .chip-container {
            display: flex;
            flex-wrap: wrap;
            gap: 5px;
            margin-top: 10px;
        }

        .chip {
            display: inline-flex;
            align-items: center;
            background-color: rgba(0, 0, 0, 0.05);
            border-radius: 15px;
            padding: 2px 8px;
            font-size: 0.8em;
            cursor: pointer;
            transition: all 0.2s;
        }

        body.dark-mode .chip {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .chip:hover {
            background-color: var(--accent-color);
            color: #000;
        }

        /* ================= Task Editor Modal ================= */
        .modal-backdrop {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background-color: rgba(0, 0, 0, 0.5);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 1000;
        }

        .modal-content {
            background-color: var(--bg-secondary-light);
            width: 90%;
            max-width: 1200px;
            max-height: 95vh;
            border-radius: var(--radius);
            overflow: hidden;
            box-shadow: var(--shadow-lg);
            display: flex;
            flex-direction: column;
        }

        body.dark-mode .modal-content {
            background-color: var(--bg-secondary-dark);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid var(--border-color-light);
        }

        body.dark-mode .modal-header {
            border-color: var(--border-color-dark);
        }

        .modal-title {
            font-size: 1.2em;
            font-weight: 600;
            margin: 0;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5em;
            cursor: pointer;
            color: var(--text-color-light);
        }

        body.dark-mode .modal-close {
            color: var(--text-color-dark);
        }

        .modal-body {
            padding: 20px;
            overflow-y: auto;
            flex: 1;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .form-control {
            width: 100%;
            padding: 10px;
            border: 1px solid var(--border-color-light);
            border-radius: var(--radius);
            background-color: var(--bg-color-light);
            color: var(--text-color-light);
            font-family: inherit;
            font-size: 0.95em;
        }

        body.dark-mode .form-control {
            background-color: var(--bg-color-dark);
            color: var(--text-color-dark);
            border-color: var(--border-color-dark);
        }

        .form-control:focus {
            outline: none;
            border-color: var(--accent-color);
        }

        .form-row {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
        }

        .form-col {
            flex: 1;
            min-width: 200px;
        }

        .modal-footer {
            padding: 15px 20px;
            border-top: 1px solid var(--border-color-light);
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        body.dark-mode .modal-footer {
            border-color: var(--border-color-dark);
        }

        .btn {
            padding: 10px 20px;
            border-radius: var(--radius);
            font-family: inherit;
            font-size: 0.95em;
            cursor: pointer;
            transition: all 0.2s;
            border: none;
        }

        .btn-primary {
            background-color: var(--accent-color);
            color: #000;
        }

        .btn-primary:hover {
            background-color: var(--accent-dark);
            transform: translateY(-2px);
        }

        .btn-secondary {
            background-color: transparent;
            border: 1px solid var (--border-color-light);
            color: var(--text-color-light);
        }

        body.dark-mode .btn-secondary {
            border-color: var(--border-color-dark);
            color: var(--text-color-dark);
        }

        .btn-secondary:hover {
            background-color: var(--hover-color-light);
            transform: translateY(-2px);
        }

        body.dark-mode .btn-secondary:hover {
            background-color: var(--hover-color-dark);
        }

        /* ================= Toast Notifications ================= */
        .toast-container {
            position: fixed;
            bottom: 20px;
            right: 20px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 1000;
        }

        .toast {
            background-color: var(--bg-secondary-light);
            color: var(--text-color-light);
            border-left: 4px solid var(--accent-color);
            padding: 15px 20px;
            border-radius: var(--radius);
            box-shadow: var(--shadow-md);
            width: 300px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            animation: slide-in 0.3s ease-out forwards;
        }

        body.dark-mode .toast {
            background-color: var(--bg-secondary-dark);
            color: var(--text-color-dark);
        }

        .toast.success {
            border-left-color: var(--status-completed);
        }

        .toast.error {
            border-left-color: var(--status-pending);
        }

        .toast.warning {
            border-left-color: var(--status-in-progress);
        }

        .toast.info {
            border-left-color: var(--status-scoping);
        }

        .toast-content {
            flex: 1;
        }

        .toast-close {
            background: none;
            border: none;
            color: var(--text-muted-light);
            cursor: pointer;
            font-size: 1.2em;
        }

        body.dark-mode .toast-close {
            color: var(--text-muted-dark);
        }

        @keyframes slide-in {
            from {
                transform: translateX(100%);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slide-out {
            from {
                transform: translateX(0);
                opacity: 1;
            }
            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        /* ================= Calendar View ================= */
        .calendar-container {
            background-color: var(--bg-secondary-light);
            border-radius: var (--radius);
            box-shadow: var(--shadow-sm);
            overflow: hidden;
        }

        body.dark-mode .calendar-container {
            background-color: var(--bg-secondary-dark);
        }

        .calendar-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 15px;
            border-bottom: 1px solid var(--border-color-light);
        }

        body.dark-mode .calendar-header {
            border-color: var(--border-color-dark);
        }

        .calendar-title {
            font-size: 1.2em;
            font-weight: 600;
            margin: 0;
        }

        .calendar-nav {
            display: flex;
            gap: 10px;
        }

        .calendar-nav-btn {
            background: transparent;
            border: 1px solid var(--border-color-light);
            color: var(--text-color-light);
            border-radius: var(--radius);
            padding: 5px 10px;
            cursor: pointer;
            transition: all 0.2s;
        }

        body.dark-mode .calendar-nav-btn {
            border-color: var (--border-color-dark);
            color: var(--text-color-dark);
        }

        .calendar-nav-btn:hover {
            background-color: var(--accent-color);
            color: #000;
        }

        .calendar-grid {
            display: grid;
            grid-template-columns: repeat(7, 1fr);
            border-collapse: collapse;
        }

        .calendar-day-header {
            padding: 10px;
            text-align: center;
            font-weight: 500;
            border-bottom: 1px solid var(--border-color-light);
        }

        body.dark-mode .calendar-day-header {
            border-color: var(--border-color-dark);
        }

        .calendar-cell {
            min-height: 100px;
            border: 1px solid var(--border-color-light);
            padding: 10px;
            position: relative;
        }

        body.dark-mode .calendar-cell {
            border-color: var(--border-color-dark);
        }

        .calendar-date {
            font-size: 0.9em;
            margin-bottom: 5px;
            font-weight: 500;
        }

        .calendar-cell.other-month {
            opacity: 0.5;
        }

        .calendar-cell.today {
            background-color: rgba(255, 215, 0, 0.1);
        }

        .calendar-event {
            padding: 5px 8px;
            border-radius: var(--radius);
            margin-bottom: 5px;
            font-size: 0.85em;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .calendar-event:hover {
            transform: translateY(-2px);
            box-shadow: var(--shadow-sm);
        }

        /* ================= Chart Containers ================= */
        .chart-container {
            background-color: var(--bg-secondary-light);
            border-radius: var(--radius);
            padding: 20px;
            box-shadow: var(--shadow-sm);
            margin-bottom: 20px;
        }

        body.dark-mode .chart-container {
            background-color: var(--bg-secondary-dark);
        }

        .chart-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .chart-title {
            font-size: 1.1em;
            font-weight: 600;
            margin: 0;
        }

        /* ================= Responsive Design ================= */
        @media (max-width: 768px) {
            .header-bar {
                grid-template-columns: 1fr;
                gap: 15px;
            }

            .branding {
                grid-column: 1;
                justify-self: center;
                transform: none;
                width: 100%;
                box-shadow: none;
                padding: 15px;
            }

            .header-controls {
                grid-column: 1;
                justify-content: center;
                flex-wrap: wrap;
                width: 100%;
            }

            .header-controls input[type="text"] {
                width: 100%;
            }

            .offset-container {
                grid-column: 1;
                width: 100%;
                justify-content: center;
            }

            .controls-bar {
                flex-direction: column;
                align-items: stretch;
            }

            .left-filters, .view-mode-container, .right-controls {
                width: 100%;
            }

            .board {
                flex-direction: column;
                gap: 20px;
            }

            .column {
                flex: 1 0 auto;
                max-height: none;
            }

            .modal-content {
                width: 95%;
            }
        }

        /* ================= Animation Keyframes ================= */
        @keyframes fadeIn {
            from {
                opacity: 0;
            }
            to {
                opacity: 1;
            }
        }

        @keyframes slideUp {
            from {
                transform: translateY(20px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        /* Add these to elements you want to animate */
        .fade-in {
            animation: fadeIn 0.3s ease-in-out;
        }

        .slide-up {
            animation: slideUp 0.3s ease-in-out;
        }

        /* ================= Floating Action Button ================= */
        .fab {
            position: fixed;
            bottom: 30px;
            right: 30px;
            width: 60px;
            height: 60px;
            border-radius: 50px;
            background-color: var(--accent-color);
            color: #000;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 24px;
            cursor: pointer;
            box-shadow: var(--shadow-md);
            transition: all 0.3s ease-in-out;
            z-index: 900;
        }
        
        .fab-icon {
            position: absolute;
            right: 20px;
            transition: transform 0.3s ease-in-out;
        }
        
        .fab-text {
            position: absolute;
            left: 20px;
            font-size: 14px;
            font-weight: bold;
            white-space: nowrap;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        .fab:hover {
            width: 180px;
            box-shadow: var(--shadow-lg);
        }
        
        .fab:hover .fab-icon {
            transform: rotate(90deg);
        }
        
        .fab:hover .fab-text {
            opacity: 1;
        }

        /* Tooltip */
        .tooltip {
            position: relative;
        }

        .tooltip:hover::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 5px 10px;
            border-radius: var(--radius);
            font-size: 0.8em;
            white-space: nowrap;
            z-index: 1000;
        }

        /* EasyMDE dark mode styles */
        body.dark-mode .EasyMDEContainer .editor-toolbar {
            background-color: var(--bg-secondary-dark) !important;
            border-color: var(--border-color-dark) !important;
        }

        body.dark-mode .EasyMDEContainer .editor-toolbar button {
            color: var(--text-color-dark) !important;
        }

        body.dark-mode .EasyMDEContainer .editor-toolbar button:hover {
            background: var(--hover-color-dark) !important;
            border-color: var(--border-color-dark) !important;
        }

        body.dark-mode .EasyMDEContainer .editor-toolbar i.separator {
            border-left: 1px solid var(--border-color-dark) !important;
            border-right: 1px solid var(--border-color-dark) !important;
        }

        .calendar-cell-dragover {
            background-color: rgba(255, 215, 0, 0.2);
            box-shadow: inset 0 0 0 2px var(--accent-color);
        }

        .calendar-cell.weekend {
            background-color: rgba(0, 0, 0, 0.05);
        }

        body.dark-mode .calendar-cell.weekend {
            background-color: rgba(255, 255, 255, 0.05);
        }

        .calendar-event {
            cursor: grab;
        }

    </style>
</head>

<body>
    <div id="root"></div>

    <!-- Service Worker Registration for Offline Capability -->
    <script>
        if ("serviceWorker" in navigator && location.protocol.match(/^https?:/)) {
            window.addEventListener("load", () => {
                navigator.serviceWorker.register("/sw.js").catch((err) => {
                    console.error("ServiceWorker registration failed:", err);
                });
            });
        }
    </script>

    <!-- React, ReactDOM, Babel -->
    <script src="https://unpkg.com/react@17/umd/react.development.js" crossorigin></script>
    <script src="https://unpkg.com/react-dom@17/umd/react-dom.development.js" crossorigin></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
        /************************************************/
        /* 0) CENTRAL CONFIGURATION OBJECT              */
        /************************************************/
        const CONFIG = {
            validDays: ["Monday", "Tuesday", "Wednesday", "Thursday", "Friday"],
            colors: {
                preset: [
                    "#000000",
                    "#CC3A0F",
                    "#00573C",
                    "#C80058",
                    "#4A1589",
                    "#654100",
                    "#004B8C",
                    "#1A3636",
                    "#660066",
                    "#003C4D",
                ],
                status: {
                    "Scoping": "#17a2b8",
                    "In Progress": "#fd7e14",
                    "Completed": "#28a745",
                    "Pending": "#dc3545"
                },
                priorities: {
                    "High": "#dc3545",
                    "Medium": "#fd7e14",
                    "Low": "#28a745",
                    "None": "#6c757d"
                }
            },
            views: {
                daily: { minOffset: -260, maxOffset: 260 }, // was -52 / +52 previously
                weekly: { minOffset: -13, maxOffset: 13 },
                monthly: { minOffset: -5, maxOffset: 5 },
            },
            dateFormat: {
                short: { day: "numeric", month: "numeric" },
                long: { month: "long", year: "numeric" },
                full: { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' }
            },
            defaultTaskStatus: "Scoping",
            defaultTaskPriority: "None",
            toastDuration: 5000, // Toast notification duration in ms
        };

        /************************************************/
        /* 1) HELPER FUNCTIONS & DEXIE SETUP            */
        /************************************************/
        const { useState, useRef, useEffect, useImperativeHandle, useCallback, useMemo, createContext, useContext } = React;

        // Unique ID generator
        const generateId = () => "_" + Math.random().toString(36).substr(2, 9);

        // Date helpers
        function formatDate(date, format = CONFIG.dateFormat.short) {
            return new Date(date).toLocaleDateString(undefined, format);
        }

        function getMonday(date) {
            const d = new Date(date);
            const day = d.getDay();
            const diff = d.getDate() - day + (day === 0 ? -6 : 1);
            return new Date(d.setDate(diff));
        }

        function computeDate(dayLabel, offset, baseMonday) {
            const dayIndex = CONFIG.validDays.indexOf(dayLabel);
            const newDate = new Date(baseMonday);
            newDate.setDate(newDate.getDate() + offset * 7 + dayIndex);
            newDate.setHours(12, 0, 0, 0);
            return newDate;
        }

        function calcWorkingDays(start, end) {
            if (!start || !end) return 0;
            const s = new Date(start);
            const e = new Date(end);
            if (s > e) return 0;
            let count = 0;
            let d = new Date(s);
            while (d <= e) {
                const day = d.getDay();
                if (day >= 1 && day <= 5) count++;
                d.setDate(d.getDate() + 1);
            }
            return count;
        }

        function truncateText(text, maxLength = 30) {
            if (!text || text.length <= maxLength) return text || "";
            const front = Math.ceil(maxLength / 2);
            const back = Math.floor(maxLength / 2);
            return text.slice(0, front) + "..." + text.slice(text.length - back);
        }

        // Fix task items - ensures proper format
        function fixTaskItems(task) {
            if (!task.items) {
                task.items = [];
            } else if (!Array.isArray(task.items)) {
                if (typeof task.items === "string" && task.items.trim().length) {
                    task.items = [task.items];
                } else {
                    task.items = [];
                }
            }
            
            // Ensure status is set
            if (!task.status) {
                task.status = CONFIG.defaultTaskStatus;
            }
            
            // Ensure priority is set
            if (!task.priority) {
                task.priority = CONFIG.defaultTaskPriority;
            }
            
            // Ensure expirationDate is a Date instance
            if (task.expirationDate && !(task.expirationDate instanceof Date)) {
                task.expirationDate = new Date(task.expirationDate);
            }
            
            // Ensure tags, users and urls are arrays
            if (!task.tags) task.tags = [];
            if (!task.users) task.users = [];
            if (!task.urls) task.urls = [];
            if (!task.attachments) task.attachments = [];
            
            return task;
        }

        // Dexie database setup (now with version 3 to include priority)
        const db = new Dexie("TaskTrackerDB");
        
        db.version(1).stores({
            tasks: "id, title, items, tags, users, color, urls, attachments, dateAssigned, dateModified, day, expirationDate",
        });

        db.version(2).stores({
            tasks: "id, title, items, tags, users, color, urls, attachments, dateAssigned, dateModified, day, expirationDate, status"
        }).upgrade(async (tx) => {
            const allTasks = await tx.tasks.toArray();
            for (const t of allTasks) {
                if (!t.status) {
                    t.status = CONFIG.defaultTaskStatus;
                }
                await tx.tasks.put(t);
            }
        });
        
        db.version(3).stores({
            tasks: "id, title, items, tags, users, color, urls, attachments, dateAssigned, dateModified, day, expirationDate, status, priority"
        }).upgrade(async (tx) => {
            const allTasks = await tx.tasks.toArray();
            for (const t of allTasks) {
                if (!t.priority) {
                    t.priority = CONFIG.defaultTaskPriority;
                }
                await tx.tasks.put(t);
            }
        });

        // NEW v4: Add dayOfMonth, month, year
        db.version(4).stores({
            tasks: `id, 
                    title, 
                    items, 
                    tags, 
                    users, 
                    color, 
                    urls, 
                    attachments, 
                    dateAssigned, 
                    dateModified, 
                    day, 
                    expirationDate, 
                    status, 
                    priority, 
                    dayOfMonth, 
                    month, 
                    year`
        }).upgrade(async (tx) => {
            const allTasks = await tx.tasks.toArray();
            for (const t of allTasks) {
                // If dateAssigned is set, extract dayOfMonth, month, year
                if (t.dateAssigned) {
                    const d = new Date(t.dateAssigned);
                    t.dayOfMonth = d.getDate();
                    t.month = d.getMonth() + 1; // 1-based
                    t.year = d.getFullYear();
                } else {
                    // If missing dateAssigned, just default to something
                    t.dayOfMonth = 1;
                    t.month = 1;
                    t.year = 1970;
                }
                await tx.tasks.put(t);
            }
        });

        // Database operation helpers with retry
        async function withRetry(operation, maxAttempts = 3) {
            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                try {
                    return await operation();
                } catch (error) {
                    if (attempt === maxAttempts) throw error;
                    await new Promise((res) => setTimeout(res, 1000 * attempt));
                }
            }
        }

        async function updateTaskInDB(task) {
            return withRetry(async () => {
                if (!CONFIG.validDays.includes(task.day)) {
                    await db.tasks.delete(task.id);
                    return;
                }
                fixTaskItems(task);
                task.dateModified = new Date();
                await db.tasks.put(task);
            });
        }

        async function deleteTaskFromDB(id) {
            return withRetry(async () => {
                await db.tasks.delete(id);
            });
        }

        async function addTaskToDB(task) {
            return withRetry(async () => {
                if (!CONFIG.validDays.includes(task.day)) return;
                fixTaskItems(task);
                task.dateModified = new Date();
                await db.tasks.add(task);
            });
        }

        /************************************************/
        /* 2) CONTEXT PROVIDERS                         */
        /************************************************/
        
        // Theme Context
        const ThemeContext = createContext();
        
        function ThemeProvider({ children }) {
            const [darkMode, setDarkMode] = useState(() => {
                const saved = localStorage.getItem("darkMode");
                return saved ? JSON.parse(saved) : false;
            });
            
            useEffect(() => {
                localStorage.setItem("darkMode", JSON.stringify(darkMode));
                document.body.classList.toggle("dark-mode", darkMode);
            }, [darkMode]);
            
            const toggleDarkMode = () => setDarkMode((prev) => !prev);
            
            return (
                <ThemeContext.Provider value={{ darkMode, toggleDarkMode }}>
                    {children}
                </ThemeContext.Provider>
            );
        }
        
        // Toast Notification Context
        const ToastContext = createContext();
        
        function ToastProvider({ children }) {
            const [toasts, setToasts] = useState([]);
            
            const addToast = useCallback((message, type = 'info') => {
                const id = generateId();
                setToasts(prev => [...prev, { id, message, type }]);
                
                // Auto remove toast after duration
                setTimeout(() => {
                    setToasts(prev => prev.filter(toast => toast.id !== id));
                }, CONFIG.toastDuration);
            }, []);
            
            const removeToast = useCallback((id) => {
                setToasts(prev => prev.filter(toast => toast.id !== id));
            }, []);
            
            return (
                <ToastContext.Provider value={{ toasts, addToast, removeToast }}>
                    {children}
                    <ToastContainer />
                </ToastContext.Provider>
            );
        }
        
        // Toast Container Component
        function ToastContainer() {
            const { toasts, removeToast } = useContext(ToastContext);
            
            return (
                <div className="toast-container">
                    {toasts.map(toast => (
                        <div key={toast.id} className={`toast ${toast.type}`}>
                            <div className="toast-content">{toast.message}</div>
                            <button className="toast-close" onClick={() => removeToast(toast.id)}>Ã—</button>
                        </div>
                    ))}
                </div>
            );
        }

        /************************************************/
        /* 3) REUSABLE COMPONENTS                       */
        /************************************************/
        
        // Markdown Editor Component
        function MarkdownEditor({ initialMarkdown, onChange }) {
            const textareaRef = useRef(null);
            const editorRef = useRef(null);

            useEffect(() => {
                const computeInitialValue = () => {
                    if (Array.isArray(initialMarkdown)) {
                        return initialMarkdown.join("\n");
                    }
                    if (typeof initialMarkdown === "string") {
                        return initialMarkdown;
                    }
                    return "";
                };

                const initialValue = computeInitialValue();
                editorRef.current = new EasyMDE({
                    element: textareaRef.current,
                    initialValue,
                    autoDownloadFontAwesome: false,
                    spellChecker: false,
                    status: [
                        "autosave",
                        {
                            className: "md-line-count",
                            defaultValue: (el) => {
                                el.innerHTML = "0 lines";
                            },
                            onUpdate: (el) => {
                                if (editorRef.current) {
                                    const lineCount = editorRef.current.codemirror.lineCount();
                                    el.innerHTML = lineCount + (lineCount === 1 ? " line" : " lines");
                                }
                            },
                        },
                        {
                            className: "md-word-count",
                            defaultValue: (el) => {
                                el.innerHTML = "0 words";
                            },
                            onUpdate: (el) => {
                                if (editorRef.current) {
                                    const str = editorRef.current.codemirror.getValue();
                                    const wordCount = (str.match(/\S+/g) || []).length;
                                    el.innerHTML = wordCount + (wordCount === 1 ? " word" : " words");
                                }
                            },
                        },
                    ],
                    autoSave: {
                        enabled: true,
                        delay: 1000,
                        uniqueId: "editorAutosave",
                    },
                    renderingConfig: {
                        singleLineBreaks: false,
                        codeSyntaxHighlighting: true,
                    },
                    toolbar: [
                        "bold", "italic", "heading", "strikethrough", "|",
                        "quote", "code", "unordered-list", "ordered-list", "|",
                        "link", "image", "table", "|",
                        "preview", "side-by-side", "fullscreen", "|",
                        "guide"
                    ],
                });

                editorRef.current.codemirror.on("change", () => {
                    const value = editorRef.current.value();
                    onChange(value);
                });

                return () => {
                    if (editorRef.current) {
                        editorRef.current.toTextArea();
                        editorRef.current = null;
                    }
                };
            }, []);

            useEffect(() => {
                if (editorRef.current) {
                    let newVal = "";
                    if (Array.isArray(initialMarkdown)) {
                        newVal = initialMarkdown.join("\n");
                    } else if (typeof initialMarkdown === "string") {
                        newVal = initialMarkdown;
                    }
                    if (editorRef.current.value() !== newVal) {
                        editorRef.current.value(newVal);
                    }
                }
            }, [initialMarkdown]);

            return (
                <div className="markdown-editor">
                    <textarea ref={textareaRef} />
                </div>
            );
        }

        // Modal Component
        function Modal({ isOpen, onClose, title, children, footer }) {
            const backdropRef = useRef(null);
            
            useEffect(() => {
                const handleEsc = (e) => {
                    if (e.key === 'Escape') onClose();
                };
                
                if (isOpen) {
                    document.addEventListener('keydown', handleEsc);
                    document.body.style.overflow = 'hidden';
                }
                
                return () => {
                    document.removeEventListener('keydown', handleEsc);
                    document.body.style.overflow = '';
                };
            }, [isOpen, onClose]);
            
            if (!isOpen) return null;
            
            const handleBackdropClick = (e) => {
                if (e.target === backdropRef.current) onClose();
            };
            
            return (
                <div className="modal-backdrop" ref={backdropRef} onClick={handleBackdropClick}>
                    <div className="modal-content slide-up">
                        <div className="modal-header">
                            <h2 className="modal-title">{title}</h2>
                            <button className="modal-close" onClick={onClose}>Ã—</button>
                        </div>
                        <div className="modal-body">{children}</div>
                        {footer && <div className="modal-footer">{footer}</div>}
                    </div>
                </div>
            );
        }

        // Chip/Tag Component
        function Chip({ text, onRemove, onClick }) {
            return (
                <div className="chip" onClick={onClick || onRemove}>
                    {text}
                    {onRemove && <span style={{ marginLeft: '5px' }}>Ã—</span>}
                </div>
            );
        }

        /************************************************/
        /* 4) TASK COMPONENTS                           */
        /************************************************/
        
        // Enhanced TaskCard component with improved drag handling
        const TaskCard = React.memo(({ 
            task, 
            day, 
            columnDate, 
            onUpdate, 
            onDelete, 
            onReorder, 
            forceCollapse, 
            searchTerm,
            onEdit 
        }) => {
            const [expanded, setExpanded] = useState(false);
            const { addToast } = useContext(ToastContext);
            const isHighlight = searchTerm ? 
                task.title.toLowerCase().includes(searchTerm.toLowerCase()) : false;
                
            // Format the date if it exists
            const formattedExpirationDate = task.expirationDate ? 
                formatDate(task.expirationDate) : null;
                
            // Calculate days remaining between the task's assigned date and expiration date
            function calcTaskRemainingDays(task) {
                if (!task || !task.expirationDate) return null;
                
                // Use the task's dateAssigned as the start date, not today's date
                // This ensures when a task is moved to a new date column, the days calculation updates
                const startDate = new Date(task.dateAssigned); 
                const endDate = new Date(task.expirationDate);
                
                return calcWorkingDays(startDate, endDate);
            }
            
            // Recalculate days remaining whenever task.dateAssigned changes
            useEffect(() => {
                if (task.expirationDate) {
                    const days = calcTaskRemainingDays(task);
                    console.log(`Task "${task.title}": ${days} days remaining`);
                }
            }, [task.dateAssigned, task.expirationDate]);
                
            const handleDelete = () => {
                onDelete(task.id);
                deleteTaskFromDB(task.id);
                addToast(`Task "${task.title}" deleted`, 'success');
            };
            
            // Priority icon mapping
            const priorityIcons = {
                'High': <i className="fas fa-flag priority-high"></i>,
                'Medium': <i className="fas fa-flag priority-medium"></i>,
                'Low': <i className="fas fa-flag priority-low"></i>,
                'None': null
            };
            
            // Get status badge class
            const getStatusClass = (status) => {
                const statusKey = status.toLowerCase().replace(/\s+/g, '-');
                return `status-${statusKey}`;
            };
            
            // Format tags for display
            const displayTags = task.tags && task.tags.length > 0 
                ? task.tags.slice(0, 3) 
                : [];
                
            const additionalTags = task.tags && task.tags.length > 3 
                ? task.tags.length - 3 
                : 0;
            
            // Enhanced drag start handler
            const handleDragStart = (e) => {
                console.log("Drag started for task:", task.id, "from day:", day);
                // Set multiple data formats for better cross-browser compatibility
                e.dataTransfer.setData("application/json", JSON.stringify({
                    taskId: task.id,
                    sourceDay: day
                }));
                e.dataTransfer.setData("text/plain", task.id);
                e.dataTransfer.setData("taskId", task.id);
                e.dataTransfer.setData("sourceDay", day);
                
                // Add visual feedback
                e.target.classList.add('dragging');
                
                // Store task data as a global fallback
                window._lastDraggedTask = {
                    id: task.id, 
                    day: day,
                    title: task.title
                };
                
                // Set drag image and effect
                e.dataTransfer.effectAllowed = "move";
            };
            
            // Enhanced drag end handler
            const handleDragEnd = (e) => {
                e.target.classList.remove('dragging');
                
                // Clean up any highlight classes
                document.querySelectorAll('.drop-zone-highlight, .column-drag-over').forEach(el => {
                    el.classList.remove('drop-zone-highlight');
                    el.classList.remove('column-drag-over');
                });
            };
            
            // Handle drop - when another task is dropped on this task
            const handleDrop = (e) => {
                e.preventDefault();
                e.stopPropagation();
                const sourceTaskId = e.dataTransfer.getData("taskId");
                const sourceDay = e.dataTransfer.getData("sourceDay");
                // Remove any condition that checks if sourceDay === day
                if (sourceTaskId && sourceTaskId !== task.id) {
                    onReorder(sourceTaskId, task.id, day);
                }
            };
            
            return (
                <div 
                    className={`task ${isHighlight ? "highlight" : ""}`}
                    style={{ borderLeftColor: task.color || "#000" }}
                    draggable={true}
                    onDragStart={handleDragStart}
                    onDragEnd={handleDragEnd}
                    onDragOver={(e) => e.preventDefault()}
                    onDrop={(e) => e.stopPropagation()} // Stop task drop from propagating to column
                    onClick={(e) => {
                        if (e.target.classList.contains('task') || e.target.classList.contains('task-title')) {
                            onEdit(task);
                        }
                    }}
                >
                    <div className="task-header">
                        <div className="task-title-wrapper">
                            <div className="task-title" onClick={() => onEdit(task)}>
                                {task.title}
                            </div>
                            <div className="status-badge-container">
                                <span className={`status-badge ${getStatusClass(task.status)}`}>
                                    {task.status}
                                </span>
                            </div>
                        </div>
                        
                        <div className="task-controls">
                            <button className="task-control-btn" onClick={handleDelete} title="Delete Task">
                                <i className="fas fa-trash"></i>
                            </button>
                            <button className="task-control-btn" onClick={() => onEdit(task)} title="Edit Task">
                                <i className="fas fa-edit"></i>
                            </button>
                        </div>
                    </div>
                    
                    {/* Priority flag */}
                    {task.priority !== 'None' && (
                        <div className="priority-flag" title={`Priority: ${task.priority}`}>
                            {priorityIcons[task.priority]}
                        </div>
                    )}
                    
                    {/* Task meta information */}
                    <div className="task-meta">
                        {formattedExpirationDate && (
                            <div className="task-meta-item" title="Due date">
                                <i className="fas fa-calendar-alt"></i>
                                <span>{formattedExpirationDate}</span>
                                {calcTaskRemainingDays(task) !== null && (
                                    <span>({calcTaskRemainingDays(task) > 0 ? `${calcTaskRemainingDays(task)} days left` : 'Overdue!'})</span>
                                )}
                            </div>
                        )}
                        
                        {task.users && task.users.length > 0 && (
                            <div className="task-meta-item" title="Assigned users">
                                <i className="fas fa-user"></i>
                                <span>{task.users[0].name}{task.users.length > 1 ? ` +${task.users.length - 1}` : ''}</span>
                            </div>
                        )}
                        
                        {task.urls && task.urls.length > 0 && (
                            <div className="task-meta-item" title="Linked URLs">
                                <i className="fas fa-link"></i>
                                <span>{task.urls.length}</span>
                            </div>
                        )}
                        
                        {task.attachments && task.attachments.length > 0 && (
                            <div className="task-meta-item" title="Attachments">
                                <i className="fas fa-paperclip"></i>
                                <span>{task.attachments.length}</span>
                            </div>
                        )}
                    </div>
                    
                    {/* Tags display */}
                    {displayTags.length > 0 && (
                        <div className="chip-container">
                            {displayTags.map((tag, i) => (
                                <Chip key={tag.id || i} text={tag.text} />
                            ))}
                            {additionalTags > 0 && <Chip text={`+${additionalTags} more`} />}
                        </div>
                    )}
                </div>
            );
        });
        
        // Task Editor Modal Component
        function TaskEditorModal({ isOpen, task, onClose, onSave }) {
            const [editTask, setEditTask] = useState({ ...task });
            const [tagInput, setTagInput] = useState('');
            const [userInput, setUserInput] = useState('');
            const [urlInput, setUrlInput] = useState('');
            const fileInputRef = useRef(null);
            const { addToast } = useContext(ToastContext);
            
            // Reset form when task changes
            useEffect(() => {
                if (isOpen) {
                    setEditTask({ ...task });
                    setTagInput('');
                    setUserInput('');
                    setUrlInput('');
                }
            }, [isOpen, task]);
            
            const handleChange = (e) => {
                const { name, value } = e.target;
                setEditTask(prev => ({ ...prev, [name]: value }));
            };
            
            const handleMarkdownChange = (newMarkdown) => {
                setEditTask(prev => ({ ...prev, items: [newMarkdown] }));
            };
            
            const handleAddTag = () => {
                if (!tagInput.trim()) return;
                const newTag = { id: generateId(), text: tagInput.trim() };
                setEditTask(prev => ({
                    ...prev, 
                    tags: [...(prev.tags || []), newTag]
                }));
                setTagInput('');
            };
            
            const handleRemoveTag = (tagId) => {
                setEditTask(prev => ({
                    ...prev,
                    tags: prev.tags.filter(tag => tag.id !== tagId)
                }));
            };
            
            const handleAddUser = () => {
                if (!userInput.trim()) return;
                const newUser = { id: generateId(), name: userInput.trim() };
                setEditTask(prev => ({
                    ...prev,
                    users: [...(prev.users || []), newUser]
                }));
                setUserInput('');
            };
            
            const handleRemoveUser = (userId) => {
                setEditTask(prev => ({
                    ...prev,
                    users: prev.users.filter(user => user.id !== userId)
                }));
            };
            
            const handleAddUrl = () => {
                if (!urlInput.trim()) return;
                const newUrl = { id: generateId(), url: urlInput.trim() };
                setEditTask(prev => ({
                    ...prev,
                    urls: [...(prev.urls || []), newUrl]
                }));
                setUrlInput('');
            };
            
            const handleRemoveUrl = (urlId) => {
                setEditTask(prev => ({
                    ...prev,
                    urls: prev.urls.filter(url => url.id !== urlId)
                }));
            };
            
            const triggerFileSelect = () => fileInputRef.current.click();
            
            const handleFileChange = (e) => {
                const files = Array.from(e.target.files).map(f => f.name);
                setEditTask(prev => ({
                    ...prev,
                    attachments: [...(prev.attachments || []), ...files]
                }));
            };
            
            const handleRemoveAttachment = (fileName) => {
                setEditTask(prev => ({
                    ...prev,
                    attachments: prev.attachments.filter(name => name !== fileName)
                }));
            };
            
            const handleSave = () => {
                // Validate required fields
                if (!editTask.title.trim()) {
                    addToast('Task title is required', 'error');
                    return;
                }
                
                onSave(editTask);
                onClose();
                addToast(`Task "${editTask.title}" saved successfully`, 'success');
            };
            
            // Form footer with action buttons
            const ModalFooter = (
                <>
                    <button className="btn btn-secondary" onClick={onClose}>Cancel</button>
                    <button className="btn btn-primary" onClick={handleSave}>Save Task</button>
                </>
            );
            
            return (
                <Modal
                    isOpen={isOpen}
                    onClose={onClose}
                    title={task.id ? "Edit Task" : "New Task"}
                    footer={ModalFooter}
                >
                    <div className="form-group">
                        <label htmlFor="title">Title</label>
                        <input
                            type="text"
                            id="title"
                            name="title"
                            className="form-control"
                            value={editTask.title || ''}
                            onChange={handleChange}
                            placeholder="Enter task title"
                        />
                    </div>
                    
                    <div className="form-row">
                        <div className="form-col">
                            <div className="form-group">
                                <label htmlFor="status">Status</label>
                                <select
                                    id="status"
                                    name="status"
                                    className="form-control"
                                    value={editTask.status || CONFIG.defaultTaskStatus}
                                    onChange={handleChange}
                                >
                                    <option value="Scoping">Scoping</option>
                                    <option value="In Progress">In Progress</option>
                                    <option value="Completed">Completed</option>
                                    <option value="Pending">Pending</option>
                                </select>
                            </div>
                        </div>
                        
                        <div className="form-col">
                            <div className="form-group">
                                <label htmlFor="priority">Priority</label>
                                <select
                                    id="priority"
                                    name="priority"
                                    className="form-control"
                                    value={editTask.priority || CONFIG.defaultTaskPriority}
                                    onChange={handleChange}
                                >
                                    <option value="None">None</option>
                                    <option value="Low">Low</option>
                                    <option value="Medium">Medium</option>
                                    <option value="High">High</option>
                                </select>
                            </div>
                        </div>
                        
                        <div className="form-col">
                            <div className="form-group">
                                <label htmlFor="expirationDate">Due Date</label>
                                <input
                                    type="date"
                                    id="expirationDate"
                                    className="form-control"
                                    value={editTask.expirationDate ? new Date(editTask.expirationDate).toISOString().split('T')[0] : ''}
                                    onChange={(e) => {
                                        const val = e.target.value ? new Date(e.target.value) : null;
                                        if (val) val.setHours(12, 0, 0, 0);
                                        setEditTask(prev => ({ ...prev, expirationDate: val }));
                                    }}
                                />
                            </div>
                        </div>
                    </div>
                    
                    <div className="form-group">
                        <label>Color</label>
                        <div style={{ display: 'flex', gap: '10px', flexWrap: 'wrap', marginTop: '10px' }}>
                            {CONFIG.colors.preset.map((color, idx) => (
                                <div
                                    key={idx}
                                    style={{
                                        width: '30px',
                                        height: '30px',
                                        backgroundColor: color,
                                        borderRadius: '5px',
                                        cursor: 'pointer',
                                        border: editTask.color === color ? '2px solid var(--accent-color)' : '2px solid transparent'
                                    }}
                                    onClick={() => setEditTask(prev => ({ ...prev, color }))}
                                    title={color}
                                />
                            ))}
                            <div style={{ 
                                marginLeft: '10px', 
                                padding: '5px', 
                                border: '1px dashed var(--border-color-light)',
                                borderRadius: '5px',
                                display: 'flex',
                                alignItems: 'center'
                            }}>
                                <label htmlFor="customColorPicker" style={{ marginRight: '8px', fontSize: '0.9em' }}>Custom:</label>
                                <input
                                    id="customColorPicker"
                                    type="color"
                                    value={editTask.color || '#000000'}
                                    onChange={(e) => setEditTask(prev => ({ ...prev, color: e.target.value }))}
                                    style={{ width: '40px', height: '30px', border: 'none', padding: 0 }}
                                />
                            </div>
                        </div>
                    </div>
                    
                    <div className="form-group">
                        <label>Task Details</label>
                        <MarkdownEditor 
                            initialMarkdown={editTask.items} 
                            onChange={handleMarkdownChange} 
                        />
                    </div>
                    
                    <div className="form-group">
                        <label>Tags</label>
                        <div style={{ display: 'flex', gap: '10px', marginBottom: '10px' }}>
                            <input
                                type="text"
                                className="form-control"
                                value={tagInput}
                                onChange={(e) => setTagInput(e.target.value)}
                                placeholder="Add a tag"
                                onKeyDown={(e) => e.key === 'Enter' && handleAddTag()}
                            />
                            <button className="btn btn-secondary" onClick={handleAddTag}>Add</button>
                        </div>
                        <div className="chip-container">
                            {editTask.tags && editTask.tags.map(tag => (
                                <Chip 
                                    key={tag.id} 
                                    text={tag.text} 
                                    onRemove={() => handleRemoveTag(tag.id)} 
                                />
                            ))}
                        </div>
                    </div>
                    
                    <div className="form-group">
                        <label>Assigned Users</label>
                        <div style={{ display: 'flex', gap: '10px', marginBottom: '10px' }}>
                            <input
                                type="text"
                                className="form-control"
                                value={userInput}
                                onChange={(e) => setUserInput(e.target.value)}
                                placeholder="Add a user"
                                onKeyDown={(e) => e.key === 'Enter' && handleAddUser()}
                            />
                            <button className="btn btn-secondary" onClick={handleAddUser}>Add</button>
                        </div>
                        <div className="chip-container">
                            {editTask.users && editTask.users.map(user => (
                                <Chip 
                                    key={user.id} 
                                    text={user.name} 
                                    onRemove={() => handleRemoveUser(user.id)} 
                                />
                            ))}
                        </div>
                    </div>
                    
                    <div className="form-group">
                        <label>URLs</label>
                        <div style={{ display: 'flex', gap: '10px', marginBottom: '10px' }}>
                            <input
                                type="text"
                                className="form-control"
                                value={urlInput}
                                onChange={(e) => setUrlInput(e.target.value)}
                                placeholder="Add a URL"
                                onKeyDown={(e) => e.key === 'Enter' && handleAddUrl()}
                            />
                            <button className="btn btn-secondary" onClick={handleAddUrl}>Add</button>
                        </div>
                        <div className="chip-container">
                            {editTask.urls && editTask.urls.map(url => (
                                <Chip 
                                    key={url.id} 
                                    text={truncateText(url.url, 30)} 
                                    onRemove={() => handleRemoveUrl(url.id)} 
                                />
                            ))}
                        </div>
                    </div>
                    
                    <div className="form-group">
                        <label>Attachments</label>
                        <div style={{ marginBottom: '10px' }}>
                            <button className="btn btn-secondary" onClick={triggerFileSelect}>
                                <i className="fas fa-paperclip"></i> Attach Files
                            </button>
                            <input
                                type="file"
                                ref={fileInputRef}
                                style={{ display: 'none' }}
                                multiple
                                onChange={handleFileChange}
                            />
                        </div>
                        <div className="chip-container">
                            {editTask.attachments && editTask.attachments.map((file, idx) => (
                                <Chip 
                                    key={idx} 
                                    text={truncateText(file, 30)} 
                                    onRemove={() => handleRemoveAttachment(file)} 
                                />
                            ))}
                        </div>
                    </div>
                </Modal>
            );
        }

        /************************************************/
        /* 5) TASK BOARD COMPONENTS                     */
        /************************************************/
        
        // Enhanced Column component with better drop handling
        const Column = React.memo(({ 
            label, 
            tasks, 
            date, 
            onAddTask, 
            onDrop, 
            onDropBetween,
            onUpdateTask,
            onDeleteTask,
            onEditTask 
        }) => {
            const [isDragOver, setIsDragOver] = useState(false);
            
            // Enhanced drag over handler
            const handleDragOver = (e) => {
                e.preventDefault(); // Critical to enable dropping
                e.currentTarget.classList.add("column-drag-over");
                e.dataTransfer.dropEffect = "move";
            };
            
            // Handle drag enter
            const handleDragEnter = (e) => {
                e.preventDefault();
                e.currentTarget.classList.add("column-drag-over");
            };
            
            // Enhanced drag leave handler
            const handleDragLeave = (e) => {
                // Only remove highlight if not entering a child element
                if (!e.currentTarget.contains(e.relatedTarget)) {
                    e.currentTarget.classList.remove("column-drag-over");
                }
            };
            
            // Enhanced drop handler with better cross-browser support
            const handleDrop = (e) => {
                e.preventDefault();
                e.stopPropagation();
                
                console.log("Drop detected in column:", label);
                e.currentTarget.classList.remove("column-drag-over");
                
                // Try multiple methods to get the task ID
                let taskId;
                let sourceDay;
                
                try {
                    // Method 1: Get from JSON
                    const jsonData = e.dataTransfer.getData("application/json");
                    if (jsonData) {
                        const data = JSON.parse(jsonData);
                        taskId = data.taskId;
                        sourceDay = data.sourceDay;
                    }
                } catch (err) {
                    console.log("Could not get JSON data:", err);
                }
                
                // Method 2: Get direct attributes
                if (!taskId) {
                    taskId = e.dataTransfer.getData("taskId");
                    sourceDay = e.dataTransfer.getData("sourceDay");
                }
                
                // Method 3: Use global fallback
                if (!taskId && window._lastDraggedTask) {
                    taskId = window._lastDraggedTask.id;
                    sourceDay = window._lastDraggedTask.day;
                    console.log("Using fallback task data:", window._lastDraggedTask);
                }
                
                // Execute the drop if we have a task ID
                if (taskId) {
                    console.log(`Moving task ${taskId} from ${sourceDay || 'unknown'} to ${label}`);
                    onDrop(e, label);
                } else {
                    console.error("No task ID found in drop event");
                }
            };
            
            return (
                <div 
                    className="column"
                    onDragOver={handleDragOver}
                    onDragEnter={handleDragOver} // Use same handler for consistency
                    onDragLeave={handleDragLeave}
                    onDrop={handleDrop}
                >
                    <div className="column-header">
                        <div>
                            <h3 className="column-title">{label}</h3>
                            {date && <div className="date-label">{date}</div>}
                        </div>
                        <button className="add-task-btn" onClick={() => onAddTask(label)} title="Add Task">
                            <i className="fas fa-plus"></i>
                        </button>
                    </div>
                    
                    <div className="column-content">
                        <div 
                            className="drop-zone top-drop-zone"
                            onDragOver={(e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                e.currentTarget.classList.add('drop-zone-highlight');
                            }}
                            onDragLeave={(e) => {
                                e.currentTarget.classList.remove('drop-zone-highlight');
                            }}
                            onDrop={(e) => {
                                e.preventDefault();
                                e.stopPropagation();
                                e.currentTarget.classList.remove('drop-zone-highlight');
                                
                                // Get task ID using multiple methods
                                const taskId = e.dataTransfer.getData("taskId") || 
                                    (window._lastDraggedTask ? window._lastDraggedTask.id : null);
                                    
                                if (taskId) {
                                    // Drop at the top of the column - before any task
                                    onDropBetween(e, tasks[0]?.id || null, label);
                                }
                            }}
                            style={{ minHeight: '10px', margin: '5px 0' }}
                        />
                        
                        {tasks.map((task, index) => (
                            <React.Fragment key={task.id}>
                                <TaskCard 
                                    task={task}
                                    day={label}
                                    onUpdate={onUpdateTask}
                                    onDelete={onDeleteTask}
                                    onEdit={onEditTask}
                                    onReorder={onDropBetween}
                                />
                                
                                <div 
                                    className="drop-zone"
                                    onDragOver={(e) => {
                                        e.preventDefault();
                                        e.stopPropagation();
                                        e.currentTarget.classList.add('drop-zone-highlight');
                                    }}
                                    onDragLeave={(e) => {
                                        e.currentTarget.classList.remove('drop-zone-highlight');
                                    }}
                                    onDrop={(e) => {
                                        e.preventDefault();
                                        e.stopPropagation();
                                        e.currentTarget.classList.remove('drop-zone-highlight');
                                        
                                        // Get task ID using multiple methods
                                        const taskId = e.dataTransfer.getData("taskId") || 
                                            (window._lastDraggedTask ? window._lastDraggedTask.id : null);
                                        
                                        if (taskId) {
                                            // Drop after this task and before the next one
                                            onDropBetween(e, tasks[index + 1]?.id || null, label);
                                        }
                                    }}
                                    style={{ minHeight: '10px', margin: '5px 0' }}
                                />
                            </React.Fragment>
                        ))}
                    </div>
                </div>
            );
        });
        
        // Task Board Component with Status View (Weekly View) Fixes
        const TaskBoard = React.forwardRef(
            ({ viewMode, offset, searchTerm, filterTag, filterUser, filterStatus, filterPriority }, ref) => {
                const [tasks, setTasks] = useState({});
                const [forceUpdate, setForceUpdate] = useState(0);
                const [editingTask, setEditingTask] = useState(null);
                const { addToast } = useContext(ToastContext);
                
                // Original baseMonday used in daily view
                const baseMonday = getMonday(new Date());
                const emptyBoard = {
                    Monday: [],
                    Tuesday: [],
                    Wednesday: [],
                    Thursday: [],
                    Friday: [],
                };

                // Load tasks from database
                useEffect(() => {
                    const fetchTasks = async () => {
                        try {
                            const fetchedTasks = await db.tasks.toArray();
                            const groupedTasks = groupTasksByDay(fetchedTasks);
                            setTasks(groupedTasks);
                        } catch (err) {
                            console.error("Error fetching tasks:", err);
                            addToast("Failed to load tasks", "error");
                        }
                    };
                    fetchTasks();
                }, [forceUpdate]);
                
                // Share boardRef with window for use in CalendarView
                useEffect(() => {
                    // Make the board ref available to other components
                    window.boardRef = ref;
                    return () => { window.boardRef = null; };
                }, [ref]);
                
                // Group tasks by day
                const groupTasksByDay = (fetchedTasks) => {
                    const board = JSON.parse(JSON.stringify(emptyBoard));
                    
                    fetchedTasks.forEach(task => {
                        // Fix any potential issues with task data
                        fixTaskItems(task);
                        
                        // For the current week offset calculation
                        if (viewMode === "daily") {
                            const currentWeekMonday = getMonday(new Date());
                            const taskDate = new Date(task.dateAssigned);
                            
                            // Calculate week difference
                            const weekDiff = Math.floor(
                                (taskDate - currentWeekMonday) / (7 * 24 * 60 * 60 * 1000)
                            );
                            
                            // Check if the task belongs to the current offset week
                            if (weekDiff === offset && CONFIG.validDays.includes(task.day)) {
                                board[task.day].push(task);
                            }
                        } else {
                            // For weekly view or other views
                            if (CONFIG.validDays.includes(task.day)) {
                                board[task.day].push(task);
                            }
                        }
                    });
                    
                    // Sort tasks in each column
                    Object.keys(board).forEach(day => {
                        board[day].sort((a, b) => {
                            // Sort by priority, then by date
                            const priorityOrder = { "High": 0, "Medium": 1, "Low": 2, "None": 3 };
                            const priorityA = priorityOrder[a.priority] || 3;
                            const priorityB = priorityOrder[b.priority] || 3;
                            
                            if (priorityA !== priorityB) return priorityA - priorityB;
                            
                            return new Date(b.dateModified || 0) - new Date(a.dateModified || 0);
                        });
                    });
                    
                    return board;
                };
                
                // Apply filters to tasks
                const filteredColumns = useMemo(() => {
                    const result = [];
                    
                    if (viewMode === 'daily') {
                        // Daily view code remains unchanged...
                        CONFIG.validDays.forEach(day => {
                            const dayDate = computeDate(day, offset, baseMonday);
                            const columnTasks = tasks[day] || [];
                            
                            // Apply filters
                            const filteredTasks = columnTasks.filter(task => {
                                // Search filter
                                if (searchTerm && !task.title.toLowerCase().includes(searchTerm.toLowerCase())) {
                                    return false;
                                }
                                
                                // Tag filter
                                if (filterTag && (!task.tags || !task.tags.some(tag => 
                                    tag.text.toLowerCase().includes(filterTag.toLowerCase())
                                ))) {
                                    return false;
                                }
                                
                                // User filter
                                if (filterUser && (!task.users || !task.users.some(user => 
                                    user.name.toLowerCase().includes(filterUser.toLowerCase())
                                ))) {
                                    return false;
                                }
                                
                                // Status filter
                                if (filterStatus && task.status !== filterStatus) {
                                    return false;
                                }
                                
                                // Priority filter
                                if (filterPriority && task.priority !== filterPriority) {
                                    return false;
                                }
                                
                                return true;
                            });
                            
                            result.push({
                                label: day,
                                tasks: filteredTasks,
                                date: formatDate(dayDate)
                            });
                        });
                    } else if (viewMode === 'weekly') {
                        // FIXED: Status View (Weekly) - improved to ensure proper status organization
                        // Create all status columns even if empty
                        const statusColumns = {
                            "Scoping": [],
                            "In Progress": [],
                            "Pending": [],
                            "Completed": []
                        };
                        
                        // Collect all tasks from all days
                        const allTasks = [];
                        Object.values(tasks).forEach(dayTasks => {
                            allTasks.push(...dayTasks);
                        });
                        
                        // Filter and group by status
                        allTasks.forEach(task => {
                            // Apply filters
                            if (
                                (searchTerm && !task.title.toLowerCase().includes(searchTerm.toLowerCase())) ||
                                (filterTag && (!task.tags || !task.tags.some(tag => 
                                    tag.text.toLowerCase().includes(filterTag.toLowerCase())
                                ))) ||
                                (filterUser && (!task.users || !task.users.some(user => 
                                    user.name.toLowerCase().includes(filterUser.toLowerCase())
                                ))) ||
                                (filterPriority && task.priority !== filterPriority)
                            ) {
                                return;
                            }
                            
                            // Group by status
                            const status = task.status || "Scoping"; // Default to Scoping if no status
                            if (statusColumns[status]) {
                                statusColumns[status].push(task);
                            }
                        });
                        
                        // Create columns from the grouped tasks
                        Object.entries(statusColumns).forEach(([status, statusTasks]) => {
                            result.push({
                                label: status,
                                tasks: statusTasks,
                                date: null
                            });
                        });
                    }
                    
                    return result;
                }, [tasks, viewMode, offset, searchTerm, filterTag, filterUser, filterStatus, filterPriority]);
                
                // Handle adding a new task
                const handleAddTask = (day) => {
                    const dateObj = computeDate(day, offset, baseMonday);
                    const newTask = {
                        id: null, // Will be set when saved
                        title: "",
                        items: [],
                        color: "#1E90E2",
                        tags: [],
                        users: [],
                        urls: [],
                        attachments: [],
                        day: day,
                        dateAssigned: dateObj,
                        expirationDate: null,
                        status: CONFIG.defaultTaskStatus,
                        priority: CONFIG.defaultTaskPriority
                    };
                    
                    setEditingTask(newTask);
                };
                
                // Handle task update
                const handleUpdateTask = (updatedTask) => {
                    setTasks(prev => {
                        const updated = { ...prev };
                        
                        // Remove from all days first (in case day was changed)
                        Object.keys(updated).forEach(day => {
                            updated[day] = updated[day].filter(task => task.id !== updatedTask.id);
                        });
                        
                        // Then add to the correct day
                        if (updated[updatedTask.day]) {
                            updated[updatedTask.day].push(updatedTask);
                        }
                        
                        return updated;
                    });
                    
                    updateTaskInDB(updatedTask);
                };
                
                // Handle task deletion
                const handleDeleteTask = (taskId) => {
                    setTasks(prev => {
                        const updated = { ...prev };
                        Object.keys(updated).forEach(day => {
                            updated[day] = updated[day].filter(task => task.id !== taskId);
                        });
                        return updated;
                    });
                    
                    deleteTaskFromDB(taskId);
                };
                
                // FIXED: Handle dropping a task into a column - now properly handles status updates in weekly view
                const handleDrop = (e, targetDay) => {
                    e.preventDefault();
                    const taskId = e.dataTransfer.getData("taskId");
                    if (!taskId) return;
                    
                    let sourceTask = null;
                    let sourceDay = null;
                    
                    // Find the task and its source day
                    Object.entries(tasks).forEach(([day, dayTasks]) => {
                        const found = dayTasks.find(task => task.id === taskId);
                        if (found) {
                            sourceTask = found;
                            sourceDay = day;
                        }
                    });
                    
                    if (!sourceTask) return;
                    
                    // Create updated task with new info
                    const updatedTask = {
                        ...sourceTask,
                        dateModified: new Date()
                    };
                    
                    // Update different properties based on view mode
                    if (viewMode === "weekly") {
                        // In status view (weekly), update the status
                        // Check if the status is actually changing
                        if (updatedTask.status === targetDay) {
                            return; // No change needed, exit early
                        }
                        
                        // Update the status
                        updatedTask.status = targetDay;
                    } else {
                        // In daily view, update the day and date
                        updatedTask.day = targetDay;
                        
                        // Update the dateAssigned to match the current week if we're in daily view
                        if (viewMode === "daily") {
                            const baseMonday = getMonday(new Date());
                            const targetDate = computeDate(targetDay, offset, baseMonday);
                            updatedTask.dateAssigned = targetDate;
                        }
                    }
                    
                    // Update the task in database
                    updateTaskInDB(updatedTask)
                        .then(() => {
                            // Success feedback
                            if (viewMode === "weekly") {
                                addToast(`Task status changed to ${targetDay}`, "success");
                            } else {
                                addToast(`Task moved to ${targetDay}`, "success");
                            }
                            
                            // Force refresh for both views to ensure UI is updated
                            setForceUpdate(prev => prev + 1);
                        })
                        .catch(err => {
                            console.error("Error updating task:", err);
                            addToast("Failed to update task", "error");
                        });
                };
                
                // Handle dropping a task between other tasks
                const handleDropBetween = (e, targetTaskId, targetDay) => {
                    e.preventDefault();
                    const taskId = e.dataTransfer.getData("taskId");
                    if (!taskId || taskId === targetTaskId) return;
                    
                    // Find the task in all tasks
                    const allTasks = Object.values(tasks).flat();
                    const sourceTask = allTasks.find(t => t.id === taskId);
                    
                    if (!sourceTask) return;
                    
                    const sourceDay = sourceTask.day;
                    
                    // Create a copy of the task with updated properties
                    const updatedTask = {
                        ...sourceTask,
                        dateModified: new Date()
                    };
                    
                    // Update properties based on view mode
                    if (viewMode === "weekly") {
                        // FIXED: In status view, update the status
                        updatedTask.status = targetDay;
                    } else {
                        // In daily view, update day and date
                        updatedTask.day = targetDay;
                        
                        // Update the dateAssigned to match the current week if we're in daily view
                        if (viewMode === "daily") {
                            const baseMonday = getMonday(new Date());
                            const targetDate = computeDate(targetDay, offset, baseMonday);
                            updatedTask.dateAssigned = targetDate;
                        }
                    }
                    
                    // Update the task in database
                    updateTaskInDB(updatedTask)
                        .then(() => {
                            // Success feedback based on view mode
                            if (viewMode === "weekly") {
                                addToast(`Task status changed to ${targetDay}`, "success");
                            } else if (sourceDay !== targetDay) {
                                addToast(`Task moved to ${targetDay}`, "success");
                            } else {
                                addToast("Task reordered", "success");
                            }
                            
                            // Force refresh
                            setForceUpdate(prev => prev + 1);
                        })
                        .catch(err => {
                            console.error("Error updating task:", err);
                            addToast("Failed to update task", "error");
                        });
                };
                
                // Handle saving a task after editing
                const handleSaveTask = async (task) => {
                    try {
                        if (task.id) {
                            // Update existing task
                            await updateTaskInDB(task);
                        } else {
                            // Add new task - generate ID first
                            const newTask = {
                                ...task,
                                id: generateId(),
                                dateModified: new Date()
                            };
                            await addTaskToDB(newTask);
                        }
                        
                        // Refresh the task list
                        setForceUpdate(prev => prev + 1);
                        
                    } catch (error) {
                        console.error("Error saving task:", error);
                        addToast("Failed to save task", "error");
                    }
                };
                
                // Forward ref methods
                useImperativeHandle(ref, () => ({
                    addTask: handleAddTask,
                    refreshTasks: () => setForceUpdate(prev => prev + 1)
                }));
                
                return (
                    <>
                        <div className="board">
                            {filteredColumns.map((column, index) => (
                                <Column
                                    key={column.label}
                                    label={column.label}
                                    tasks={column.tasks}
                                    date={column.date}
                                    onAddTask={handleAddTask}
                                    onDrop={(e) => handleDrop(e, column.label)}
                                    onDropBetween={handleDropBetween}
                                    onUpdateTask={handleUpdateTask}
                                    onDeleteTask={handleDeleteTask}
                                    onEditTask={setEditingTask}
                                />
                            ))}
                        </div>
                        
                        {/* Task Editor Modal */}
                        <TaskEditorModal
                            isOpen={editingTask !== null}
                            task={editingTask || {}}
                            onClose={() => setEditingTask(null)}
                            onSave={handleSaveTask}
                        />
                    </>
                );
            }
        );

        /************************************************/
        /* 6) SUMMARY & VISUALIZATION COMPONENTS        */
        /************************************************/

        // TaskSummaryText component with proper memoization
        const TaskSummaryText = React.memo(({ tasks }) => {
            const { addToast } = useContext(ToastContext);
            const { darkMode } = useContext(ThemeContext);
            const [isCopied, setIsCopied] = useState(false);
            
            // Memoized markdown output
            const markdownOutput = useMemo(() => {
                const prompt = `You are a professional business solution consultant. I will provide you with a set of table entries (Title, Items, Tags, Users, URLs). Your job is to: 1. Summarize the table in concise bullet points. 2. Group similar tasks or notes if they share the same Tags or Users. 3. If an entry is missing Items, Tags, Users, or URLs, write "None" for that field. 4. End with a short concluding statement (1â€“2 sentences) highlighting any patterns or important insights. Make sure the final output contains: - Bullet points listing each entry, in a consistent format (e.g., "**Title**: â€¦ | **Items**: â€¦ | **Tags**: â€¦ | **Users**: â€¦ | **URLs**: â€¦"). No extra commentary beyond this summary. A final sentence or two as a conclusion. Use only the data provided; do not make up additional facts. Here is the [FILTERED TABLE] data:`;
                
                let markdownEntries = tasks.map(task => {
                    // Format items
                    const items = task.items && task.items.length > 0 
                        ? (Array.isArray(task.items) 
                            ? task.items.join(" ") 
                            : task.items.toString())
                        : "None";
                        
                    // Format tags
                    const tags = task.tags && task.tags.length > 0 
                        ? task.tags.map(tag => tag.text).join(", ") 
                        : "None";
                        
                    // Format users
                    const users = task.users && task.users.length > 0 
                        ? task.users.map(user => user.name).join(", ") 
                        : "None";
                        
                    // Format URLs
                    const urls = task.urls && task.urls.length > 0 
                        ? task.urls.map(url => url.url).join(", ") 
                        : "None";
                        
                    return `- **Title**: ${task.title} | **Items**: ${items} | **Tags**: ${tags} | **Users**: ${users} | **URLs**: ${urls} | **Status**: ${task.status} | **Priority**: ${task.priority}`;
                }).join("\n");
                
                return `${prompt}\n\n${markdownEntries}`;
            }, [tasks]);
            
            // Memoized lines for display
            const displayLines = useMemo(() => {
                return markdownOutput.split('\n').map((line, index) => ({
                    id: index,
                    text: line
                }));
            }, [markdownOutput]);
            
            const handleCopy = () => {
                navigator.clipboard.writeText(markdownOutput)
                    .then(() => {
                        setIsCopied(true);
                        addToast("Task summary copied to clipboard", "success");
                        
                        // Reset copy status after 2 seconds
                        setTimeout(() => {
                            setIsCopied(false);
                        }, 2000);
                    })
                    .catch(err => {
                        console.error("Failed to copy:", err);
                        addToast("Failed to copy to clipboard", "error");
                    });
            };
            
            return (
                <div className="chart-container" style={{ marginBottom: '20px' }}>
                    <div className="chart-header" style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                        <h3 className="chart-title">Task Summary for LLM Analysis</h3>
                        <button 
                            className="btn btn-primary" 
                            onClick={handleCopy}
                            style={{ 
                                display: 'flex', 
                                alignItems: 'center', 
                                gap: '8px',
                                transition: 'all 0.2s ease'
                            }}
                        >
                            {isCopied ? (
                                <>
                                    <i className="fas fa-check"></i>
                                    Copied!
                                </>
                            ) : (
                                <>
                                    <i className="fas fa-copy"></i>
                                    Copy Prompt
                                </>
                            )}
                        </button>
                    </div>
                    <div style={{ 
                        padding: '15px', 
                        maxHeight: '200px', 
                        overflowY: 'auto',
                        backgroundColor: darkMode ? '#121212' : '#f8f9fa',
                        border: `1px solid ${darkMode ? '#343a40' : '#dee2e6'}`,
                        borderRadius: '8px',
                        fontSize: '0.9em',
                        fontFamily: 'monospace'
                    }}>
                        <p style={{ marginBottom: '10px', fontWeight: 'bold' }}>LLM Prompt with {tasks.length} filtered tasks:</p>
                        <div style={{ opacity: 0.7 }}>
                            {displayLines.slice(0, 20).map((line) => (
                                <div key={line.id} style={{ 
                                    whiteSpace: 'nowrap', 
                                    overflow: 'hidden', 
                                    textOverflow: 'ellipsis',
                                    marginBottom: '4px'
                                }}>
                                    {line.text}
                                </div>
                            ))}
                            {displayLines.length > 20 && (
                                <div style={{ fontStyle: 'italic', marginTop: '8px' }}>
                                    ...and {displayLines.length - 20} more lines
                                </div>
                            )}
                        </div>
                    </div>
                </div>
            );
        });

        // Calendar View Component with Direct Database Calls
        function CalendarView({ tasks = [] }) {
            const [currentDate, setCurrentDate] = useState(new Date());
            const [localTasks, setLocalTasks] = useState([]);
            const [dbStatus, setDbStatus] = useState("");
            const { addToast } = useContext(ToastContext);
            
            // Load tasks directly from the database
            useEffect(() => {
                const loadAllTasks = async () => {
                    try {
                        // Get tasks directly from the database instead of using props
                        const allTasks = await db.tasks.toArray();
                        console.log("Database loaded tasks:", allTasks.length);
                        setLocalTasks(allTasks);
                    } catch (err) {
                        console.error("Failed to load tasks from database:", err);
                        // Fall back to props as a backup
                        setLocalTasks(tasks);
                    }
                };
                
                loadAllTasks();
            }, [tasks]);
            
            // Generate calendar days for the current month
            const calendarDays = useMemo(() => {
                const days = [];
                const year = currentDate.getFullYear();
                const month = currentDate.getMonth();
                
                // First day of the month 
                const firstDay = new Date(year, month, 1);
                const startingDayOfWeek = firstDay.getDay();
                
                // Last day of the month
                const lastDay = new Date(year, month + 1, 0);
                const totalDays = lastDay.getDate();
                
                // Get days from previous month to fill first week
                const daysToFill = startingDayOfWeek === 0 ? 6 : startingDayOfWeek - 1;
                const prevMonthLastDay = new Date(year, month, 0).getDate();
                for (let i = daysToFill; i > 0; i--) {
                    days.push({
                        day: prevMonthLastDay - i + 1,
                        month: month - 1,
                        year: month === 0 ? year - 1 : year,
                        currentMonth: false
                    });
                }
                
                // Current month days
                for (let i = 1; i <= totalDays; i++) {
                    days.push({
                        day: i,
                        month,
                        year,
                        currentMonth: true
                    });
                }
                
                // Next month days to complete the grid
                const remainingDays = 42 - days.length;
                for (let i = 1; i <= remainingDays; i++) {
                    days.push({
                        day: i,
                        month: month + 1,
                        year,
                        currentMonth: false
                    });
                }
                
                return days;
            }, [currentDate]);
            
            // Navigation
            const goToPrevMonth = () => {
                setCurrentDate(prev => {
                    const newDate = new Date(prev);
                    newDate.setMonth(prev.getMonth() - 1);
                    return newDate;
                });
            };
            
            const goToNextMonth = () => {
                setCurrentDate(prev => {
                    const newDate = new Date(prev);
                    newDate.setMonth(prev.getMonth() + 1);
                    return newDate;
                });
            };
            
            const formattedMonthYear = new Intl.DateTimeFormat('en-US', { 
                month: 'long', 
                year: 'numeric' 
            }).format(currentDate);
            
            // Get tasks for a specific date
            const getTasksForDate = (day, month, year) => {
                return localTasks.filter(task => {
                    if (!task.dateAssigned) return false;
                    
                    const taskDate = new Date(task.dateAssigned);
                    return (
                        taskDate.getDate() === day && 
                        taskDate.getMonth() === month && 
                        taskDate.getFullYear() === year
                    );
                });
            };
            
            // Check if a date is today
            const isToday = (day, month, year) => {
                const today = new Date();
                return day === today.getDate() && 
                    month === today.getMonth() && 
                    year === today.getFullYear();
            };
            
            // DIRECT DATABASE APPROACH - No helper functions
            const moveTaskToDate = async (taskId, targetDay, targetMonth, targetYear) => {
                try {
                    setDbStatus(`Moving task ${taskId}...`);
                    
                    // Step 1: Get the task directly from the database
                    const task = await db.tasks.get(taskId);
                    
                    if (!task) {
                        console.error("Task not found:", taskId);
                        setDbStatus("Task not found!");
                        addToast("Error: Task not found", "error");
                        return;
                    }
                    
                    setDbStatus(`Got task: ${task.title}`);
                    
                    // Step 2: Create the target date (noon to avoid timezone issues)
                    const targetDate = new Date(targetYear, targetMonth, targetDay, 12, 0, 0, 0);
                    
                    // Step 3: Get the day of week (0-6, 0 is Sunday)
                    const dayOfWeek = targetDate.getDay();
                    
                    // Check if it's a weekend
                    if (dayOfWeek === 0 || dayOfWeek === 6) {
                        setDbStatus("Cannot move to weekend!");
                        addToast("Tasks can only be assigned to weekdays", "error");
                        return;
                    }
                    
                    // Step 4: Map day number to day name
                    const dayNames = ["Sunday", "Monday", "Tuesday", "Wednesday", "Thursday", "Friday", "Saturday"];
                    const newDayName = dayNames[dayOfWeek];
                    
                    // Step 5: Create a new task object with updated values
                    const updatedTask = {
                        ...task,
                        dateAssigned: targetDate,
                        day: newDayName,
                        dateModified: new Date()
                    };
                    
                    setDbStatus(`Updating database...`);
                    
                    // Step 6: Put the updated task directly in the database
                    await db.tasks.put(updatedTask);
                    
                    setDbStatus(`Database updated. Refreshing...`);
                    
                    // Step 7: Reload all tasks to refresh the view
                    const refreshedTasks = await db.tasks.toArray();
                    setLocalTasks(refreshedTasks);
                    
                    // Step 8: Refresh the board if available
                    if (window.boardRef && window.boardRef.current) {
                        window.boardRef.current.refreshTasks();
                        setDbStatus("Board refreshed");
                    }
                    
                    // Step 9: Show success message
                    addToast(`Task moved to ${newDayName}, ${targetMonth+1}/${targetDay}/${targetYear}`, "success");
                    
                    // Clear status after a delay
                    setTimeout(() => setDbStatus(""), 3000);
                    
                } catch (err) {
                    console.error("Database error:", err);
                    setDbStatus(`ERROR: ${err.message}`);
                    addToast(`Database error: ${err.message}`, "error");
                }
            };
            
            return (
                <div className="calendar-container">
                    {/* Database status display */}
                    {dbStatus && (
                        <div style={{
                            position: 'fixed',
                            top: 50,
                            right: 10,
                            background: '#333',
                            color: '#fff',
                            padding: '8px 12px',
                            borderRadius: '4px',
                            zIndex: 9999,
                            maxWidth: '300px',
                            wordBreak: 'break-word'
                        }}>
                            <strong>DB:</strong> {dbStatus}
                        </div>
                    )}
                    
                    <div className="calendar-header">
                        <h2 className="calendar-title">{formattedMonthYear}</h2>
                        <div className="calendar-nav">
                            <button className="calendar-nav-btn" onClick={goToPrevMonth}>
                                <i className="fas fa-chevron-left"></i> Prev
                            </button>
                            <button className="calendar-nav-btn" onClick={goToNextMonth}>
                                Next <i className="fas fa-chevron-right"></i>
                            </button>
                        </div>
                    </div>
                    
                    <div className="calendar-grid">
                        {/* Weekday headers */}
                        {['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'].map(day => (
                            <div key={day} className="calendar-day-header">{day}</div>
                        ))}
                        
                        {/* Calendar cells */}
                        {calendarDays.map((dayObj, index) => {
                            const dayTasks = getTasksForDate(dayObj.day, dayObj.month, dayObj.year);
                            const isWeekend = new Date(dayObj.year, dayObj.month, dayObj.day).getDay() % 6 === 0;
                            
                            return (
                                <div 
                                    key={index} 
                                    className={`calendar-cell ${!dayObj.currentMonth ? 'other-month' : ''} 
                                            ${isToday(dayObj.day, dayObj.month, dayObj.year) ? 'today' : ''} 
                                            ${isWeekend ? 'weekend' : ''}`}
                                    // Simple drop zone functionality
                                    onDragOver={!isWeekend ? (e) => {
                                        e.preventDefault();
                                        e.currentTarget.classList.add('calendar-cell-dragover');
                                    } : undefined}
                                    
                                    onDragLeave={(e) => {
                                        e.currentTarget.classList.remove('calendar-cell-dragover');
                                    }}
                                    
                                    onDrop={!isWeekend ? (e) => {
                                        e.preventDefault();
                                        e.currentTarget.classList.remove('calendar-cell-dragover');
                                        
                                        // Try to get task ID from data transfer
                                        let taskId = e.dataTransfer.getData('text');
                                        
                                        // If no taskId found in the data transfer, try global variable
                                        if (!taskId && window._draggedTaskId) {
                                            taskId = window._draggedTaskId;
                                        }
                                        
                                        // If we have a task ID, move the task
                                        if (taskId) {
                                            moveTaskToDate(taskId, dayObj.day, dayObj.month, dayObj.year);
                                        } else {
                                            setDbStatus("No task ID found in drop event");
                                        }
                                    } : undefined}
                                >
                                    <div className="calendar-date">{dayObj.day}</div>
                                    <div className="calendar-events">
                                        {dayTasks.slice(0, 3).map(task => (
                                            <div 
                                                key={task.id} 
                                                className="calendar-event" 
                                                style={{ 
                                                    backgroundColor: task.color || '#1E90E2', 
                                                    color: '#fff' 
                                                }}
                                                title={task.title}
                                                draggable={true}
                                                onDragStart={(e) => {
                                                    // Set data in text format for maximum compatibility
                                                    e.dataTransfer.setData('text', task.id);
                                                    
                                                    // Global backup
                                                    window._draggedTaskId = task.id;
                                                    
                                                    // Visual feedback
                                                    e.target.style.opacity = 0.5;
                                                    
                                                    setDbStatus(`Dragging: ${task.title}`);
                                                }}
                                                onDragEnd={(e) => {
                                                    e.target.style.opacity = 1;
                                                }}
                                            >
                                                {task.title}
                                                {task.priority !== 'None' && (
                                                    <span style={{ marginLeft: '5px' }}>
                                                        {task.priority === 'High' ? 'âš ï¸' : 
                                                        task.priority === 'Medium' ? 'â—' : 'â€¢'}
                                                    </span>
                                                )}
                                            </div>
                                        ))}
                                        {dayTasks.length > 3 && (
                                            <div className="calendar-event-more" style={{ 
                                                textAlign: 'center', 
                                                fontSize: '0.8em', 
                                                color: 'var(--text-muted-light)' 
                                            }}>
                                                +{dayTasks.length - 3} more
                                            </div>
                                        )}
                                    </div>
                                </div>
                            );
                        })}
                    </div>
                </div>
            );
        }

        // GanttChartView with custom virtualization - no external dependencies
        const GanttChartView = React.memo(({ tasks = [], filterTag = "", filterStatus = "", filterPriority = "", filterUser = "", startDate = "", endDate = "" }) => {
            const [dateRange, setDateRange] = useState({ start: null, end: null });
            const [chartData, setChartData] = useState([]);
            const { darkMode } = useContext(ThemeContext);
            const containerRef = useRef(null);
            const [dimensions, setDimensions] = useState({ width: 1000, height: 500 });
            const [scrollTop, setScrollTop] = useState(0);
            const [visibleRange, setVisibleRange] = useState({ start: 0, end: 20 });
            const rowHeight = 40; // Height of each row in pixels
            
            // Calculate the date range for all tasks and prepare chart data
            useEffect(() => {
                if (tasks.length === 0) return;
                
                // Using the filterTag passed via props directly
                const currentFilterTag = filterTag;
                
                // Use the filtered tasks directly from props
                let filteredTasks = [...tasks];
                
                // Apply date filters
                if (startDate || endDate) {
                    filteredTasks = filteredTasks.filter(task => {
                        if (!task.dateAssigned) return false;
                        
                        const taskDate = new Date(task.dateAssigned);
                        
                        // Filter by start date if provided
                        if (startDate) {
                            const filterStartDate = new Date(startDate);
                            if (taskDate < filterStartDate) return false;
                        }
                        
                        // Filter by end date if provided
                        if (endDate) {
                            const filterEndDate = new Date(endDate);
                            filterEndDate.setHours(23, 59, 59, 999); // End of day
                            if (taskDate > filterEndDate) return false;
                        }
                        
                        return true;
                    });
                }
                
                // Find earliest and latest dates
                let minDate = new Date();
                let maxDate = new Date();
                let hasValidDates = false;
                
                // If date filters are provided, use them for min/max dates
                if (startDate) {
                    minDate = new Date(startDate);
                    hasValidDates = true;
                }
                
                if (endDate) {
                    maxDate = new Date(endDate);
                    maxDate.setHours(23, 59, 59, 999); // End of day
                    hasValidDates = true;
                }
                
                // If no date filters, determine from tasks
                if (!startDate || !endDate) {
                    filteredTasks.forEach(task => {
                        if (task.dateAssigned) {
                            const assignedDate = new Date(task.dateAssigned);
                            if (!hasValidDates || (!startDate && assignedDate < minDate)) minDate = assignedDate;
                            hasValidDates = true;
                        }
                        
                        if (task.expirationDate) {
                            const expDate = new Date(task.expirationDate);
                            if (!hasValidDates || (!endDate && expDate > maxDate)) maxDate = expDate;
                            hasValidDates = true;
                        }
                    });
                }
                
                if (!hasValidDates) {
                    // If no valid dates, use current date range (last 2 weeks to next 2 weeks)
                    minDate = new Date();
                    minDate.setDate(minDate.getDate() - 14);
                    maxDate = new Date();
                    maxDate.setDate(maxDate.getDate() + 14);
                } else {
                    // Ensure we have at least a 2-week span
                    const twoWeeksMs = 14 * 24 * 60 * 60 * 1000;
                    if (maxDate - minDate < twoWeeksMs) {
                        maxDate = new Date(minDate.getTime() + twoWeeksMs);
                    }
                }
                
                // Adjust min date to the beginning of the week
                minDate = getMonday(minDate);
                
                // Adjust max date to the end of the week
                maxDate = new Date(maxDate);
                const daysUntilSunday = 7 - maxDate.getDay();
                maxDate.setDate(maxDate.getDate() + daysUntilSunday);
                
                setDateRange({ start: minDate, end: maxDate });
                
                // Group tasks by tag and status
                const tagGroups = {};
                
                // If a filter tag is specified, only create that single tag group
                if (currentFilterTag) {
                    // Only create a group for the filtered tag
                    tagGroups[currentFilterTag] = {
                        tag: currentFilterTag,
                        tasks: []
                    };
                    
                    // Add all tasks that have this tag to this group
                    filteredTasks.forEach(task => {
                        if (task.tags && task.tags.some(tag => tag.text === currentFilterTag)) {
                            // Add task to the group - we'll now keep the full task object
                            tagGroups[currentFilterTag].tasks.push(task);
                        }
                    });
                } else {
                    // No tag filter - handle as before (show all tags)
                    filteredTasks.forEach(task => {
                        if (!task.tags || task.tags.length === 0) {
                            // Handle tasks with no tags
                            const noTagKey = "No Tag";
                            if (!tagGroups[noTagKey]) {
                                tagGroups[noTagKey] = {
                                    tag: noTagKey,
                                    tasks: []
                                };
                            }
                            tagGroups[noTagKey].tasks.push(task);
                        } else {
                            // Handle tasks with tags (add to all matching tag groups)
                            task.tags.forEach(tag => {
                                const tagKey = tag.text;
                                if (!tagGroups[tagKey]) {
                                    tagGroups[tagKey] = {
                                        tag: tagKey,
                                        tasks: []
                                    };
                                }
                                tagGroups[tagKey].tasks.push(task);
                            });
                        }
                    });
                }
                
                // Convert to array for rendering
                const chartRows = Object.values(tagGroups);
                
                // Now sort the tasks within each tag group
                chartRows.forEach(group => {
                    // Sort tasks by title
                    group.tasks.sort((a, b) => {
                        return a.title.localeCompare(b.title);
                    });
                });
                
                setChartData(chartRows);
                
            }, [tasks, filterTag, startDate, endDate]);
            
            // Update dimensions when container size changes
            useEffect(() => {
                if (!containerRef.current) return;
                
                const updateDimensions = () => {
                    if (containerRef.current) {
                        setDimensions({
                            width: containerRef.current.clientWidth,
                            height: Math.min(window.innerHeight * 0.6, 600) // Limit height
                        });
                    }
                };
                
                updateDimensions();
                window.addEventListener('resize', updateDimensions);
                
                return () => window.removeEventListener('resize', updateDimensions);
            }, []);
            
            // Generate the date columns for the chart
            const dateColumns = useMemo(() => {
                if (!dateRange.start || !dateRange.end) return [];
                
                const dates = [];
                let currentDate = new Date(dateRange.start);
                
                while (currentDate <= dateRange.end) {
                    dates.push(new Date(currentDate));
                    currentDate.setDate(currentDate.getDate() + 1);
                }
                
                return dates;
            }, [dateRange]);
            
            // Check if a task is active on a given date
            const isTaskActiveOnDate = useCallback((task, date) => {
                if (!task.dateAssigned) return false;
                
                const taskStartDate = new Date(task.dateAssigned);
                taskStartDate.setHours(0, 0, 0, 0);
                
                const taskEndDate = task.expirationDate 
                    ? new Date(task.expirationDate) 
                    : new Date(taskStartDate);
                taskEndDate.setHours(23, 59, 59, 999);
                
                const compareDate = new Date(date);
                compareDate.setHours(12, 0, 0, 0);
                
                return compareDate >= taskStartDate && compareDate <= taskEndDate;
            }, []);
            
            // Format date for display
            const formatColumnDate = useCallback((date) => {
                return new Date(date).toLocaleDateString(undefined, { 
                    day: 'numeric', 
                    month: 'short' 
                });
            }, []);
            
            // Get weekend class
            const isWeekend = useCallback((date) => {
                const day = date.getDay();
                return day === 0 || day === 6 ? 'weekend' : '';
            }, []);
            
            // Get background color for a cell based on the task status
            const getCellBackground = useCallback((task, date) => {
                if (!isTaskActiveOnDate(task, date)) {
                    return {
                        background: 'transparent',
                        content: ''
                    };
                }
                
                // Use the task's status to determine color
                let color;
                switch(task.status) {
                    case 'Scoping':
                        color = 'rgba(23, 162, 184, 0.7)';
                        break;
                    case 'In Progress':
                        color = 'rgba(253, 126, 20, 0.7)';
                        break;
                    case 'Completed':
                        color = 'rgba(40, 167, 69, 0.7)';
                        break;
                    case 'Pending':
                        color = 'rgba(220, 53, 69, 0.7)';
                        break;
                    default:
                        color = 'rgba(0,0,0,0.05)';
                }
                
                return {
                    background: color,
                    content: '1'
                };
            }, [isTaskActiveOnDate]);
            
            // Flatten chart data for virtualization
            const flattenedChartData = useMemo(() => {
                const flatData = [];
                chartData.forEach((tagGroup, tagIdx) => {
                    tagGroup.tasks.forEach((task, taskIdx) => {
                        flatData.push({
                            tagGroup,
                            task,
                            tagIdx,
                            taskIdx,
                            isFirstTaskInGroup: taskIdx === 0
                        });
                    });
                });
                return flatData;
            }, [chartData]);
            
            // Handle scroll event
            const handleScroll = useCallback((e) => {
                const newScrollTop = e.target.scrollTop;
                setScrollTop(newScrollTop);
                
                // Calculate which items should be visible
                const startIndex = Math.floor(newScrollTop / rowHeight);
                const visibleItems = Math.ceil(dimensions.height / rowHeight) + 5; // Add buffer
                
                setVisibleRange({
                    start: Math.max(0, startIndex - 5), // Buffer above
                    end: Math.min(flattenedChartData.length, startIndex + visibleItems + 5) // Buffer below
                });
            }, [dimensions.height, flattenedChartData.length]);
            
            // Initialize visible range when data changes
            useEffect(() => {
                const visibleItems = Math.ceil(dimensions.height / rowHeight) + 10; // Add buffer
                setVisibleRange({
                    start: 0,
                    end: Math.min(flattenedChartData.length, visibleItems)
                });
            }, [flattenedChartData, dimensions.height]);
            
            if (!dateRange.start || chartData.length === 0) {
                return (
                    <div style={{ padding: '20px', textAlign: 'center' }}>
                        No data available for timeline view
                    </div>
                );
            }
            
            // Render row
            const renderRow = (item, index) => {
                if (!item) return null;
                
                const { tagGroup, task, isFirstTaskInGroup } = item;
                
                return (
                    <div key={`${task.id}-${index}`} style={{ 
                        display: 'flex', 
                        width: '100%', 
                        height: `${rowHeight}px`,
                        borderBottom: `1px solid var(--border-color-${darkMode ? 'dark' : 'light'})`,
                        position: 'absolute',
                        top: `${index * rowHeight}px`,
                        left: 0,
                        right: 0
                    }}>
                        {/* Tag column - only shown for the first task in each tag group */}
                        {isFirstTaskInGroup && (
                            <div style={{ 
                                width: 150, 
                                padding: '10px', 
                                fontWeight: 'bold',
                                overflow: 'hidden',
                                textOverflow: 'ellipsis',
                                whiteSpace: 'nowrap'
                            }}>
                                {tagGroup.tag}
                            </div>
                        )}
                        
                        {!isFirstTaskInGroup && (
                            <div style={{ width: 150 }}></div>
                        )}
                        
                        {/* Title column */}
                        <div style={{ 
                            width: 200, 
                            padding: '10px', 
                            fontWeight: '500',
                            overflow: 'hidden',
                            textOverflow: 'ellipsis',
                            whiteSpace: 'nowrap'
                        }}>
                            {task.title}
                        </div>
                        
                        {/* Status column */}
                        <div style={{ 
                            width: 120, 
                            padding: '10px'
                        }}>
                            <span className={`status-badge status-${task.status.toLowerCase().replace(/\s+/g, '-')}`}>
                                {task.status}
                            </span>
                        </div>
                        
                        {/* Date grid - rendered as individual cells */}
                        <div style={{ display: 'flex', flex: 1, overflow: 'hidden' }}>
                            {dateColumns.map((date, dateIdx) => {
                                const cellStyle = getCellBackground(task, date);
                                return (
                                    <div 
                                        key={dateIdx} 
                                        className={isWeekend(date)}
                                        style={{ 
                                            width: 80,
                                            height: '100%',
                                            background: cellStyle.background || (isWeekend(date) ? `rgba(0,0,0,0.05)` : ''),
                                            textAlign: 'center',
                                            fontWeight: cellStyle.content ? 'bold' : 'normal',
                                            color: cellStyle.content ? '#fff' : 'inherit',
                                            display: 'flex',
                                            alignItems: 'center',
                                            justifyContent: 'center'
                                        }}
                                        title={`${task.title} - ${task.status}: ${cellStyle.content ? 'Active' : 'Inactive'} on ${formatColumnDate(date)}`}
                                    >
                                        {cellStyle.content}
                                    </div>
                                );
                            })}
                        </div>
                    </div>
                );
            };
            
            return (
                <div className="chart-container" style={{ marginBottom: '20px' }} ref={containerRef}>
                    <div className="chart-header">
                        <h3 className="chart-title">Task Timeline by Tag</h3>
                        {(startDate || endDate) && (
                            <div style={{ fontSize: '0.9em', opacity: 0.8 }}>
                                <i className="fas fa-filter" style={{ marginRight: '5px' }}></i>
                                {startDate ? `From ${new Date(startDate).toLocaleDateString()}` : ''}
                                {startDate && endDate ? ' to ' : ''}
                                {endDate ? `${new Date(endDate).toLocaleDateString()}` : ''}
                            </div>
                        )}
                    </div>
                    
                    {/* Column Headers */}
                    <div style={{ 
                        display: 'flex', 
                        borderBottom: '1px solid #ccc',
                        fontWeight: 'bold'
                    }}>
                        <div style={{ width: 150, padding: '10px', textAlign: 'left' }}>Tag</div>
                        <div style={{ width: 200, padding: '10px', textAlign: 'left' }}>Title</div>
                        <div style={{ width: 120, padding: '10px', textAlign: 'left' }}>Status</div>
                        
                        {/* Date column headers */}
                        <div style={{ display: 'flex', flex: 1, overflowX: 'hidden' }}>
                            {dateColumns.map((date, idx) => (
                                <div 
                                    key={idx} 
                                    className={isWeekend(date)}
                                    style={{ 
                                        width: 80, 
                                        padding: '10px', 
                                        textAlign: 'center',
                                        backgroundColor: isWeekend(date) ? 'rgba(0,0,0,0.05)' : '',
                                        fontSize: '0.85em',
                                        overflow: 'hidden',
                                        whiteSpace: 'nowrap',
                                        textOverflow: 'ellipsis'
                                    }}
                                >
                                    {formatColumnDate(date)}
                                </div>
                            ))}
                        </div>
                    </div>
                    
                    {/* Virtualized rows container */}
                    <div 
                        style={{ 
                            height: `${Math.min(500, flattenedChartData.length * rowHeight)}px`, 
                            position: 'relative',
                            overflowY: 'auto',
                            overflowX: 'hidden'
                        }}
                        onScroll={handleScroll}
                    >
                        <div style={{ 
                            height: `${flattenedChartData.length * rowHeight}px`, 
                            position: 'relative'
                        }}>
                            {flattenedChartData
                                .slice(visibleRange.start, visibleRange.end)
                                .map((item, i) => renderRow(item, visibleRange.start + i))}
                        </div>
                    </div>
                </div>
            );
        });

        // Tasks Table Component with Pagination
        const TasksTable = React.memo(({ tasks }) => {
            // Pagination state
            const [currentPage, setCurrentPage] = useState(1);
            const tasksPerPage = 20;
            
            // Sort tasks by status and priority - memoized to prevent recalculation
            const sortedTasks = useMemo(() => {
                return [...tasks].sort((a, b) => {
                    // Status order: In Progress, Pending, Scoping, Completed
                    const statusOrder = { "In Progress": 0, "Pending": 1, "Scoping": 2, "Completed": 3 };
                    const statusA = statusOrder[a.status] || 0;
                    const statusB = statusOrder[b.status] || 0;
                    
                    if (statusA !== statusB) return statusA - statusB;
                    
                    // Priority order: High, Medium, Low, None
                    const priorityOrder = { "High": 0, "Medium": 1, "Low": 2, "None": 3 };
                    const priorityA = priorityOrder[a.priority] || 3;
                    const priorityB = priorityOrder[b.priority] || 3;
                    
                    return priorityA - priorityB;
                });
            }, [tasks]);
            
            // Calculate current tasks to display
            const indexOfLastTask = currentPage * tasksPerPage;
            const indexOfFirstTask = indexOfLastTask - tasksPerPage;
            const currentTasks = sortedTasks.slice(indexOfFirstTask, indexOfLastTask);
            
            // Calculate total pages
            const totalPages = Math.max(1, Math.ceil(sortedTasks.length / tasksPerPage));
            
            // Handle page changes
            const handlePageChange = (newPage) => {
                setCurrentPage(Math.max(1, Math.min(newPage, totalPages)));
            };
            
            // Reset to page 1 when tasks change
            useEffect(() => {
                setCurrentPage(1);
            }, [tasks.length]);
            
            if (sortedTasks.length === 0) {
                return <div style={{ padding: '20px', textAlign: 'center' }}>No tasks match the current filters</div>;
            }
            
            return (
                <div>
                    <div style={{ overflowX: 'auto' }}>
                        <table style={{ width: '100%', borderCollapse: 'collapse' }}>
                            <thead>
                                <tr>
                                    <th style={{ padding: '10px', textAlign: 'left', borderBottom: '1px solid var(--border-color-light)' }}>Title</th>
                                    <th style={{ padding: '10px', textAlign: 'left', borderBottom: '1px solid var(--border-color-light)' }}>Status</th>
                                    <th style={{ padding: '10px', textAlign: 'left', borderBottom: '1px solid var(--border-color-light)' }}>Priority</th>
                                    <th style={{ padding: '10px', textAlign: 'left', borderBottom: '1px solid var(--border-color-light)' }}>Day</th>
                                    <th style={{ padding: '10px', textAlign: 'left', borderBottom: '1px solid var(--border-color-light)' }}>Date Assigned</th>
                                    <th style={{ padding: '10px', textAlign: 'left', borderBottom: '1px solid var(--border-color-light)' }}>Due Date</th>
                                    <th style={{ padding: '10px', textAlign: 'left', borderBottom: '1px solid var(--border-color-light)' }}>Assigned To</th>
                                </tr>
                            </thead>
                            <tbody>
                                {currentTasks.map(task => (
                                    <tr key={task.id}>
                                        <td style={{ padding: '10px', borderBottom: '1px solid var(--border-color-light)' }}>{task.title}</td>
                                        <td style={{ padding: '10px', borderBottom: '1px solid var(--border-color-light)' }}>
                                            <span className={`status-badge status-${task.status.toLowerCase().replace(/\s+/g, '-')}`}>
                                                {task.status}
                                            </span>
                                        </td>
                                        <td style={{ padding: '10px', borderBottom: '1px solid var(--border-color-light)' }}>
                                            {task.priority !== 'None' && (
                                                <span style={{ color: CONFIG.colors.priorities[task.priority] }}>
                                                    {task.priority}
                                                </span>
                                            )}
                                            {task.priority === 'None' && <span>-</span>}
                                        </td>
                                        <td style={{ padding: '10px', borderBottom: '1px solid var(--border-color-light)' }}>{task.day}</td>
                                        <td style={{ padding: '10px', borderBottom: '1px solid var(--border-color-light)' }}>
                                            {task.dateAssigned ? formatDate(task.dateAssigned, { day: "numeric", month: "numeric", year: "numeric" }) : '-'}
                                        </td>
                                        <td style={{ padding: '10px', borderBottom: '1px solid var(--border-color-light)' }}>
                                            {task.expirationDate ? formatDate(task.expirationDate, { day: "numeric", month: "numeric", year: "numeric" }) : '-'}
                                        </td>
                                        <td style={{ padding: '10px', borderBottom: '1px solid var(--border-color-light)' }}>
                                            {task.users && task.users.length > 0 ? 
                                                task.users.map(u => u.name).join(', ') : 
                                                '-'
                                            }
                                        </td>
                                    </tr>
                                ))}
                            </tbody>
                        </table>
                    </div>
                    
                    {/* Pagination Controls */}
                    {totalPages > 1 && (
                        <div style={{ 
                            display: 'flex', 
                            justifyContent: 'space-between', 
                            alignItems: 'center', 
                            marginTop: '15px',
                            padding: '8px 0'
                        }}>
                            <div>
                                <span style={{ fontSize: '0.9em' }}>
                                    Showing {indexOfFirstTask + 1}-{Math.min(indexOfLastTask, sortedTasks.length)} of {sortedTasks.length} tasks
                                </span>
                            </div>
                            <div style={{ display: 'flex', gap: '5px' }}>
                                <button 
                                    className="btn btn-secondary" 
                                    onClick={() => handlePageChange(1)} 
                                    disabled={currentPage === 1}
                                    style={{ padding: '5px 10px' }}
                                >
                                    <i className="fas fa-angle-double-left"></i>
                                </button>
                                <button 
                                    className="btn btn-secondary" 
                                    onClick={() => handlePageChange(currentPage - 1)} 
                                    disabled={currentPage === 1}
                                    style={{ padding: '5px 10px' }}
                                >
                                    <i className="fas fa-angle-left"></i>
                                </button>
                                <span style={{ 
                                    display: 'flex', 
                                    alignItems: 'center', 
                                    padding: '0 10px',
                                    fontSize: '0.9em'
                                }}>
                                    Page {currentPage} of {totalPages}
                                </span>
                                <button 
                                    className="btn btn-secondary" 
                                    onClick={() => handlePageChange(currentPage + 1)} 
                                    disabled={currentPage === totalPages}
                                    style={{ padding: '5px 10px' }}
                                >
                                    <i className="fas fa-angle-right"></i>
                                </button>
                                <button 
                                    className="btn btn-secondary" 
                                    onClick={() => handlePageChange(totalPages)} 
                                    disabled={currentPage === totalPages}
                                    style={{ padding: '5px 10px' }}
                                >
                                    <i className="fas fa-angle-double-right"></i>
                                </button>
                            </div>
                        </div>
                    )}
                </div>
            );
        });

        // Summary view with optimized performance - Charts removed
        function SummaryView({ tasks = [], filterTag = "", filterStatus = "", filterPriority = "", filterUser = "", startDate = "", endDate = "" }) {
            const { darkMode } = useContext(ThemeContext);
            
            // Filter tasks by date range - memoized
            const filteredTasks = useMemo(() => {
                return tasks.filter(task => {
                    // Skip tasks without dates
                    if (!task.dateAssigned) return true;
                    
                    const taskDate = new Date(task.dateAssigned);
                    
                    // Filter by start date if provided
                    if (startDate) {
                        const filterStartDate = new Date(startDate);
                        if (taskDate < filterStartDate) return false;
                    }
                    
                    // Filter by end date if provided
                    if (endDate) {
                        const filterEndDate = new Date(endDate);
                        filterEndDate.setHours(23, 59, 59, 999); // End of day
                        if (taskDate > filterEndDate) return false;
                    }
                    
                    return true;
                });
            }, [tasks, startDate, endDate]);
            
            // Date filter information display
            const getDateFilterInfo = () => {
                if (!startDate && !endDate) return "";
                
                const formatDate = (dateStr) => {
                    return new Date(dateStr).toLocaleDateString();
                };
                
                if (startDate && endDate) {
                    return `Date Range: ${formatDate(startDate)} - ${formatDate(endDate)}`;
                } else if (startDate) {
                    return `From: ${formatDate(startDate)}`;
                } else {
                    return `Until: ${formatDate(endDate)}`;
                }
            };
            
            return (
                <div className="summary-view">
                    {/* Date filter information banner */}
                    {(startDate || endDate) && (
                        <div style={{
                            background: darkMode ? 'rgba(255, 215, 0, 0.2)' : 'rgba(255, 215, 0, 0.1)',
                            padding: '10px 15px',
                            marginBottom: '15px',
                            borderRadius: 'var(--radius)',
                            display: 'flex',
                            alignItems: 'center',
                            justifyContent: 'space-between'
                        }}>
                            <div>
                                <i className="fas fa-calendar-alt" style={{ marginRight: '8px' }}></i>
                                <span>{getDateFilterInfo()}</span>
                            </div>
                            <span style={{ fontSize: '0.85em' }}>
                                Showing {filteredTasks.length} of {tasks.length} tasks
                            </span>
                        </div>
                    )}
                    
                    {/* Tasks Overview Table with Pagination */}
                    <div className="chart-container" style={{ marginBottom: '20px' }}>
                        <div className="chart-header">
                            <h3 className="chart-title">Tasks Overview</h3>
                        </div>
                        <TasksTable tasks={filteredTasks} />
                    </div>
                    
                    {/* Add TaskSummaryText component */}
                    <TaskSummaryText tasks={filteredTasks} />
                    
                    {/* Gantt Chart View with task limit */}
                    {filteredTasks.length <= 100 ? (
                        <GanttChartView 
                            tasks={filteredTasks} 
                            filterTag={filterTag}
                            filterStatus={filterStatus}
                            filterPriority={filterPriority}
                            filterUser={filterUser}
                            startDate={startDate}
                            endDate={endDate}
                        />
                    ) : (
                        <div className="chart-container" style={{ marginBottom: '20px', padding: '20px', textAlign: 'center' }}>
                            <div className="chart-header">
                                <h3 className="chart-title">Task Timeline</h3>
                            </div>
                            <div style={{ 
                                padding: '30px 20px', 
                                background: darkMode ? 'rgba(255,255,255,0.05)' : 'rgba(0,0,0,0.03)', 
                                borderRadius: 'var(--radius)',
                                marginTop: '20px'
                            }}>
                                <i className="fas fa-exclamation-triangle" style={{ fontSize: '2em', color: 'var(--accent-color)', marginBottom: '15px', display: 'block' }}></i>
                                <h4>Timeline view is disabled for large datasets</h4>
                                <p>You currently have {filteredTasks.length} tasks selected. Please use filters to reduce to 100 or fewer tasks to enable the timeline view.</p>
                            </div>
                        </div>
                    )}
                </div>
            );
        }

        /************************************************/
        /* 7) MAIN APP COMPONENT                        */
        /************************************************/

        function App() {
            const { darkMode, toggleDarkMode } = useContext(ThemeContext);
            const [viewMode, setViewMode] = useState("daily");
            const [offset, setOffset] = useState(0);
            const [searchTerm, setSearchTerm] = useState("");
            const [filterTag, setFilterTag] = useState("");
            const [filterUser, setFilterUser] = useState("");
            const [filterStatus, setFilterStatus] = useState("");
            const [filterPriority, setFilterPriority] = useState("");
            const [startDate, setStartDate] = useState(""); 
            const [endDate, setEndDate] = useState(""); 
            const [allTags, setAllTags] = useState([]);
            const [allUsers, setAllUsers] = useState([]);
            const [tasks, setTasks] = useState([]);
            const [showQuickAdd, setShowQuickAdd] = useState(false);
            const [showHelp, setShowHelp] = useState(false);
            const [showDexie, setShowDexie] = useState(false);
            const [showExcalidraw, setShowExcalidraw] = useState(false); 
            const [dbTasks, setDbTasks] = useState([]);
            const [showCredits, setShowCredits] = useState(false);
            
            const boardRef = useRef(null);
            const importFileRef = useRef(null);
            const { addToast } = useContext(ToastContext);
            
            useEffect(() => {
                const loadData = async () => {
                    try {
                        const fetchedTasks = await db.tasks.toArray();
                        fetchedTasks.forEach(task => fixTaskItems(task));
                        setTasks(fetchedTasks);
                        
                        const tagSet = new Set();
                        const userSet = new Set();
                        
                        fetchedTasks.forEach(task => {
                            if (task.tags && task.tags.length) {
                                task.tags.forEach(tag => tagSet.add(tag.text));
                            }
                            
                            if (task.users && task.users.length) {
                                task.users.forEach(user => userSet.add(user.name));
                            }
                        });
                        
                        setAllTags(Array.from(tagSet));
                        setAllUsers(Array.from(userSet));
                        
                        if (boardRef.current) {
                            boardRef.current.refreshTasks();
                        }
                        
                    } catch (error) {
                        console.error("Error loading data:", error);
                        addToast("Failed to load task data", "error");
                    }
                };
                
                loadData();
            }, [offset]);
            
            const handleSearchChange = (e) => {
                setSearchTerm(e.target.value);
            };
            
            const handleQuickAddTask = () => {
                if (boardRef.current) {
                    const today = new Date();
                    const dayIndex = today.getDay() - 1; // 0 = Monday
                    const day = dayIndex >= 0 && dayIndex < 5 ? CONFIG.validDays[dayIndex] : "Monday";
                    
                    boardRef.current.addTask(day);
                }
            };
            
            const handleStartDateChange = (e) => {
                const newStartDate = e.target.value;
                setStartDate(newStartDate);
                
                if (endDate && new Date(endDate) < new Date(newStartDate)) {
                    setEndDate("");
                    addToast("End date must be after start date", "warning");
                }
            };
            
            const handleEndDateChange = (e) => {
                const newEndDate = e.target.value;
                setEndDate(newEndDate);
                
                if (startDate && new Date(startDate) > new Date(newEndDate)) {
                    setStartDate("");
                    addToast("Start date must be before end date", "warning");
                }
            };
            
            const showDexieTable = async () => {
                try {
                    const tasks = await db.tasks.toArray();
                    tasks.forEach(task => fixTaskItems(task));
                    tasks.sort((a, b) => 
                        new Date(b.dateModified || 0) - new Date(a.dateModified || 0)
                    );
                    setDbTasks(tasks);
                    setShowDexie(true);
                } catch (err) {
                    console.error("Error reading tasks from DB:", err);
                    addToast("Failed to load database", "error");
                }
            };
            
            const handleImportClick = () => {
                if (importFileRef.current) {
                    importFileRef.current.value = "";
                    importFileRef.current.click();
                }
            };

            function parseFormattedDate(dateStr) {
                if (!dateStr) return null;
                const parts = dateStr.split('/');
                if (parts.length !== 3) return null;
                
                return new Date(`${parts[2]}-${parts[1]}-${parts[0]}T12:00:00`);
            }

            function processCSVRow(row) {
                return {
                    id: row[0] || generateId(),
                    title: row[1] || "Untitled Task",
                    status: row[2] || CONFIG.defaultTaskStatus,
                    priority: row[3] || CONFIG.defaultTaskPriority,
                    day: row[4] || "Monday",
                    dateAssigned: row[5] ? parseFormattedDate(row[5]) : new Date(),
                    expirationDate: row[6] ? parseFormattedDate(row[6]) : null,
                    tags: row[7]
                    ? row[7].split(";").map((t) => ({ id: generateId(), text: t.trim() }))
                    : [],
                    users: row[8]
                    ? row[8].split(";").map((u) => ({ id: generateId(), name: u.trim() }))
                    : [],
                    urls: row[9]
                    ? row[9].split(";").map((url) => ({ id: generateId(), url: url.trim() }))
                    : [],
                    items: row[10] ? row[10].split("|").map(item => item.trim()) : [],
                    attachments: row[11] ? row[11].split(";").map(att => att.trim()) : [],
                    dateModified: new Date(),
                    color: row[12] || "#000000",
                };
            }
            
            const handleImportFile = async (e) => {
                if (!e.target.files?.length) return;
                const file = e.target.files[0];
                const reader = new FileReader();
                
                reader.onload = async (evt) => {
                    const contents = evt.target.result;
                    try {
                        const lines = contents.split(/\r?\n/);
                        lines.shift(); // Skip header row
                        
                        const tasksToImport = [];
                        
                        for (let line of lines) {
                            line = line.trim();
                            if (!line) continue;
                            
                            let row = [];
                            let inQuotes = false;
                            let currentField = '';
                            
                            for (let i = 0; i < line.length; i++) {
                                const char = line[i];
                                
                                if (char === '"') {
                                    if (inQuotes && i + 1 < line.length && line[i + 1] === '"') {
                                        currentField += '"';
                                        i++; 
                                    } else {
                                        inQuotes = !inQuotes;
                                    }
                                } else if (char === ',' && !inQuotes) {
                                    row.push(currentField);
                                    currentField = '';
                                } else {
                                    currentField += char;
                                }
                            }
                            row.push(currentField);
                            
                            if (row.length < 3) continue;
                            
                            console.log("Processing row:", row);
                            console.log("Date assigned input:", row[5]);
                            console.log("Due date input:", row[6]);
                            console.log("Attachments input:", row[11]);
                            
                            const taskObj = processCSVRow(row);
                            
                            console.log("Parsed date assigned:", taskObj.dateAssigned);
                            console.log("Parsed expiration date:", taskObj.expirationDate);
                            console.log("Parsed attachments:", taskObj.attachments);
                            
                            fixTaskItems(taskObj);
                            tasksToImport.push(taskObj);
                        }
                        
                        if (tasksToImport.length > 0) {
                            await db.tasks.clear();
                            await db.tasks.bulkAdd(tasksToImport);
                            
                            addToast(`Imported ${tasksToImport.length} tasks successfully`, "success");
                            
                            if (boardRef.current) {
                                boardRef.current.refreshTasks();
                            }
                        } else {
                            addToast("No valid tasks found to import", "warning");
                        }
                    } catch (error) {
                        console.error("Error importing file:", error);
                        addToast(`Error importing file: ${error.message}`, "error");
                    }
                };
                
                reader.readAsText(file);
            };
            
            const handleExportCSV = async () => {
                try {
                    const fetchedTasks = await db.tasks.toArray();
                    if (fetchedTasks.length === 0) {
                        addToast("No tasks to export", "info");
                        return;
                    }
                    
                    const header = [
                        "ID", "Title", "Status", "Priority", "Day", 
                        "Date Assigned", "Due Date", "Tags", "Users", "URLs", 
                        "Task Details", "Attachments", "Color"
                    ].join(",");
                    
                    const rows = fetchedTasks.map(task => {
                        const tagText = task.tags?.map(t => t.text).join("; ") || "";
                        const userText = task.users?.map(u => u.name).join("; ") || "";
                        const urlText = task.urls?.map(u => u.url).join("; ") || "";
                        const taskDetails = task.items 
                            ? (Array.isArray(task.items) ? task.items.join(" | ") : task.items.toString()) 
                            : "";
                        const attachmentText = task.attachments?.join("; ") || "";
                            
                        return [
                            task.id,
                            `"${task.title.replace(/"/g, '""')}"`,
                            task.status,
                            task.priority,
                            task.day,
                            task.dateAssigned 
                                ? formatDate(task.dateAssigned, { day: "numeric", month: "numeric", year: "numeric" }) 
                                : "",
                            task.expirationDate 
                                ? formatDate(task.expirationDate, { day: "numeric", month: "numeric", year: "numeric" }) 
                                : "",
                            `"${tagText.replace(/"/g, '""')}"`,
                            `"${userText.replace(/"/g, '""')}"`,
                            `"${urlText.replace(/"/g, '""')}"`,
                            `"${taskDetails.replace(/"/g, '""')}"`,
                            `"${attachmentText.replace(/"/g, '""')}"`,
                            task.color || ""
                        ].join(",");
                    });
                    
                    const csvContent = [header, ...rows].join("\n");
                    
                    const blob = new Blob([csvContent], { type: "text/csv;charset=utf-8;" });
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement("a");
                    link.setAttribute("href", url);
                    link.setAttribute("download", `tasks_export_${new Date().toISOString().slice(0, 10)}.csv`);
                    link.style.visibility = "hidden";
                    document.body.appendChild(link);
                    link.click();
                    document.body.removeChild(link);
                    
                    addToast("Tasks exported successfully", "success");
                } catch (error) {
                    console.error("Error exporting tasks:", error);
                    addToast("Failed to export tasks", "error");
                }
            };
            
            const handleResetFilters = () => {
                setSearchTerm("");
                setFilterTag("");
                setFilterUser("");
                setFilterStatus("");
                setFilterPriority("");
                setStartDate("");
                setEndDate("");
                setOffset(0);
                addToast("All filters reset", "info");
            };
            
            const renderViewComponent = () => {
                const filteredTasks = tasks.filter(task => {
                    if (searchTerm && !task.title.toLowerCase().includes(searchTerm.toLowerCase())) {
                        return false;
                    }
                    
                    if (filterTag && (!task.tags || !task.tags.some(tag => 
                        tag.text.toLowerCase().includes(filterTag.toLowerCase())
                    ))) {
                        return false;
                    }
                    
                    if (filterUser && (!task.users || !task.users.some(user => 
                        user.name.toLowerCase().includes(filterUser.toLowerCase())
                    ))) {
                        return false;
                    }
                    
                    if (filterStatus && task.status !== filterStatus) {
                        return false;
                    }
                    
                    if (filterPriority && task.priority !== filterPriority) {
                        return false;
                    }
                    
                    if (startDate && task.dateAssigned) {
                        const taskDate = new Date(task.dateAssigned);
                        const filterStartDate = new Date(startDate);
                        if (taskDate < filterStartDate) {
                            return false;
                        }
                    }
                    
                    if (endDate && task.dateAssigned) {
                        const taskDate = new Date(task.dateAssigned);
                        const filterEndDate = new Date(endDate);
                        filterEndDate.setHours(23, 59, 59, 999);
                        if (taskDate > filterEndDate) {
                            return false;
                        }
                    }
                    
                    return true;
                });

                switch (viewMode) {
                    case "daily":
                    case "weekly":
                        return (
                            <TaskBoard
                                ref={boardRef}
                                viewMode={viewMode}
                                offset={offset}
                                searchTerm={searchTerm}
                                filterTag={filterTag}
                                filterUser={filterUser}
                                filterStatus={filterStatus}
                                filterPriority={filterPriority}
                                startDate={startDate}
                                endDate={endDate}
                            />
                        );
                    case "monthly":
                        return <CalendarView tasks={filteredTasks} />;
                    case "summary":
                        return <SummaryView 
                            tasks={filteredTasks}
                            filterTag={filterTag}
                            filterStatus={filterStatus}
                            filterPriority={filterPriority}
                            filterUser={filterUser}
                            startDate={startDate}
                            endDate={endDate}
                        />;
                    default:
                        return null;
                }
            };
            
            // Simple Help Modal Component
            const HelpModal = ({ onClose }) => (
                <Modal isOpen={true} onClose={onClose} title="Help & Keyboard Shortcuts">
                    <div>
                        <h3>Basic Usage</h3>
                        <ul>
                            <li>Create new tasks using the + button in columns or the floating action button</li>
                            <li>Drag and drop tasks between columns</li>
                            <li>Click on a task to edit details</li>
                            <li>Use filters to focus on specific tasks</li>
                        </ul>
                        
                        <h3>Keyboard Shortcuts</h3>
                        <ul>
                            <li><strong>Ctrl/Cmd + N</strong>: Create a new task</li>
                            <li><strong>Ctrl/Cmd + F</strong>: Focus search bar</li>
                            <li><strong>Esc</strong>: Close open modals</li>
                        </ul>
                        
                        <h3>View Modes</h3>
                        <ul>
                            <li><strong>Daily</strong>: See tasks by weekday</li>
                            <li><strong>Weekly</strong>: See tasks by status</li>
                            <li><strong>Monthly</strong>: Calendar view</li>
                            <li><strong>Summary</strong>: Charts and statistics</li>
                        </ul>
                        
                        <h3>Filtering</h3>
                        <ul>
                            <li>Use the filter controls to focus on specific tags, users, statuses, or priorities</li>
                            <li>Use the date range filters to see tasks within a specific time period</li>
                        </ul>
                    </div>
                </Modal>
            );
            
            // Dexie Modal Component 
            const DexieModal = ({ tasks, onClose }) => {
                const compactView = true;
                const coreFields = ["ID", "Title", "Status", "Priority", "Day", "Date Assigned", "Due Date"];
                const expandedFields = ["Items", "Tags", "Users", "URLs", "Date Modified", "Due Date"];
                const displayFields = compactView ? coreFields : [...coreFields, ...expandedFields];
                
                return (
                    <Modal
                        isOpen={true}
                        onClose={onClose}
                        title="Dexie Task Database"
                    >
                        <div style={{ maxWidth: '100%' }}>
                            <div style={{ display: 'flex', justifyContent: 'space-between', marginBottom: '10px' }}>
                                <div>
                                    <strong>Total Tasks:</strong> {tasks.length}
                                </div>
                            </div>
                            
                            <table style={{ 
                                width: '100%', 
                                borderCollapse: 'collapse',
                                tableLayout: 'fixed'
                            }}>
                                <thead>
                                    <tr>
                                        {displayFields.map(header => (
                                            <th key={header} style={{ 
                                                border: '1px solid var(--border-color-light)', 
                                                padding: '8px', 
                                                textAlign: 'left',
                                                whiteSpace: 'nowrap',
                                                overflow: 'hidden',
                                                textOverflow: 'ellipsis'
                                            }}>
                                                {header}
                                            </th>
                                        ))}
                                    </tr>
                                </thead>
                                <tbody>
                                    {tasks.map(task => (
                                        <tr key={task.id}>
                                        <td style={{ border: '1px solid var(--border-color-light)', padding: '8px', 
                                            overflow: 'hidden', textOverflow: 'ellipsis', maxWidth: '80px' }}>
                                            {task.id}
                                        </td>
                                        <td style={{ border: '1px solid var(--border-color-light)', padding: '8px',
                                            overflow: 'hidden', textOverflow: 'ellipsis' }}>
                                            {task.title}
                                        </td>
                                        <td style={{ border: '1px solid var(--border-color-light)', padding: '8px' }}>
                                            {task.status}
                                        </td>
                                        <td style={{ border: '1px solid var(--border-color-light)', padding: '8px' }}>
                                            {task.priority}
                                        </td>
                                        <td style={{ border: '1px solid var(--border-color-light)', padding: '8px' }}>
                                            {task.day}
                                        </td>
                                        <td style={{ border: '1px solid var(--border-color-light)', padding: '8px' }}>
                                            {task.dateAssigned
                                            ? formatDate(task.dateAssigned, { day: "numeric", month: "numeric", year: "numeric" })
                                            : ""}
                                        </td>
                                        <td style={{ border: '1px solid var(--border-color-light)', padding: '8px' }}>
                                            {task.expirationDate
                                            ? formatDate(task.expirationDate, { day: "numeric", month: "numeric", year: "numeric" })
                                            : ""}
                                        </td>
                                        {!compactView && (
                                            <>
                                            <td style={{ border: '1px solid var(--border-color-light)', padding: '8px' }}>
                                                {Array.isArray(task.items)
                                                ? task.items.join(" | ").substring(0, 20) + "..."
                                                : ""}
                                            </td>
                                            <td style={{ border: '1px solid var(--border-color-light)', padding: '8px' }}>
                                                {task.tags?.map(t => t.text).join(", ")}
                                            </td>
                                            <td style={{ border: '1px solid var(--border-color-light)', padding: '8px' }}>
                                                {task.users?.map(u => u.name).join(", ")}
                                            </td>
                                            <td style={{ border: '1px solid var(--border-color-light)', padding: '8px' }}>
                                                {task.urls?.map(u => u.url).join(", ")}
                                            </td>
                                            <td style={{ border: '1px solid var(--border-color-light)', padding: '8px' }}>
                                                {task.dateModified ? formatDate(task.dateModified) : ""}
                                            </td>
                                            <td style={{ border: '1px solid var(--border-color-light)', padding: '8px' }}>
                                                {task.expirationDate ? formatDate(task.expirationDate) : ""}
                                            </td>
                                            </>
                                        )}
                                        </tr>
                                    ))}
                                </tbody>
                            </table>
                        </div>
                    </Modal>
                );
            };
            
            // Excalidraw Modal Component
            const ExcalidrawModal = ({ onClose }) => {
                return (
                    <Modal isOpen={true} onClose={onClose} title="Excalidraw Whiteboard">
                        <div style={{ height: "85vh", width: "100%" }}>
                            <iframe 
                                src="https://excalidraw.com/" 
                                style={{ 
                                    width: "100%", 
                                    height: "100%", 
                                    border: "none",
                                    borderRadius: "var(--radius)"
                                }}
                                title="Excalidraw Whiteboard"
                                allow="accelerometer; clipboard-read; clipboard-write"
                                sandbox="allow-scripts allow-same-origin allow-forms"
                            />
                        </div>
                    </Modal>
                );
            };

            // Credits Modal Component
            const CreditsModal = ({ onClose }) => {
                return (
                    <Modal isOpen={true} onClose={onClose} title="Credits">
                        <div>
                            <h3>Development Team</h3>
                            <ul>
                                <li>TaskCo is developed by the Aladdin Family</li>
                                <li>Special thanks to the entire development team</li>
                            </ul>
                            
                            <h3>Contact</h3>
                            <p>For questions, support, or feedback:</p>
                            <ul>
                                <li><strong>Email:</strong> ning.lu@blackrock.com</li>
                            </ul>
                        </div>
                    </Modal>
                );
            };
            
            return (
                <div className="container">
                    <header className="app-header">
                        <div className="header-bar">
                            {/* Left side - control buttons */}
                            <div className="header-controls">
                                <button className="header-btn" onClick={toggleDarkMode} title="Toggle Dark/Light Mode">
                                    {darkMode ? <i className="fas fa-sun"></i> : <i className="fas fa-moon"></i>}
                                    {darkMode ? "" : ""}
                                </button>
                                <button className="header-btn" onClick={showDexieTable} title="View Database">
                                    <i className="fas fa-database"></i>
                                </button>
                                <button className="header-btn" onClick={handleImportClick} title="Import Tasks">
                                    <i className="fas fa-file-import"></i>
                                </button>
                                <button className="header-btn" onClick={handleExportCSV} title="Export Tasks">
                                    <i className="fas fa-file-export"></i>
                                </button>
                                <button className="header-btn" onClick={() => setShowExcalidraw(true)} title="Open Excalidraw">
                                    <i className="fas fa-pencil-alt"></i>
                                </button>
                                <button className="header-btn" onClick={() => setShowHelp(true)} title="Help">
                                    <i className="fas fa-question-circle"></i>
                                </button>
                                <button className="header-btn" onClick={() => window.location.href = "mailto:ning.lu@blackrock.com?subject=Feedback%20to%20TaskCo"} title="Send Feedback">
                                    <i className="fas fa-envelope"></i>
                                </button>
                                <button className="header-btn" onClick={() => setShowCredits(true)} title="Credits">
                                    <i className="fas fa-users"></i>
                                </button>
                                <input
                                    type="file"
                                    ref={importFileRef}
                                    style={{ display: 'none' }}
                                    accept=".csv"
                                    onChange={handleImportFile}
                                />
                            </div>
                            
                            {/* Center - branding */}
                            <div className="branding" 
                                onClick={() => {
                                    setViewMode("daily");
                                    setOffset(0);
                                    addToast("Returned to today's view", "info");
                                }}
                                style={{ cursor: 'pointer' }}
                                title="Return to today's view"
                            >
                                <h1>TaskCo</h1>
                                <h2>the Hug ðŸ¤— Spreadsheets Wonâ€™t Show.</h2>
                            </div>
                            
                            {/* Right side - search bar */}
                            <div className="right-controls" style={{ justifyContent: 'flex-end' }}>
                                <input 
                                    type="text"
                                    placeholder="Search tasks..."
                                    value={searchTerm}
                                    onChange={handleSearchChange}
                                    className="form-control"
                                    style={{ width: '280px', marginRight: '15px' }}
                                />
                            </div>
                        </div>
                    </header>
                    
                    <main className="main-content">
                        <div className="controls-bar">
                            <div className="left-filters" style={{ 
                                display: 'flex', 
                                alignItems: 'center',
                                gap: '8px',  // Use gap instead of margins for more compact layout
                                width: '100%'
                            }}>
                                <span style={{ 
                                    fontSize: '0.9em', 
                                    fontWeight: '500', 
                                    whiteSpace: 'nowrap' 
                                }}>Filter by:</span>
                                
                                <select 
                                    className="filter-select" 
                                    value={filterTag} 
                                    onChange={(e) => setFilterTag(e.target.value)}
                                    style={{ width: '110px', flex: '0 0 auto' }}
                                >
                                    <option value="">Tag</option>
                                    {allTags.map(tag => (
                                        <option key={tag} value={tag}>{tag}</option>
                                    ))}
                                </select>
                                
                                <select 
                                    className="filter-select" 
                                    value={filterUser} 
                                    onChange={(e) => setFilterUser(e.target.value)}
                                    style={{ width: '110px', flex: '0 0 auto' }}
                                >
                                    <option value="">User</option>
                                    {allUsers.map(user => (
                                        <option key={user} value={user}>{user}</option>
                                    ))}
                                </select>
                                
                                <select 
                                    className="filter-select" 
                                    value={filterStatus} 
                                    onChange={(e) => setFilterStatus(e.target.value)}
                                    style={{ width: '110px', flex: '0 0 auto' }}
                                >
                                    <option value="">Status</option>
                                    <option value="Scoping">Scoping</option>
                                    <option value="In Progress">In Progress</option>
                                    <option value="Completed">Completed</option>
                                    <option value="Pending">Pending</option>
                                </select>
                                
                                <select 
                                    className="filter-select" 
                                    value={filterPriority} 
                                    onChange={(e) => setFilterPriority(e.target.value)}
                                    style={{ width: '110px', flex: '0 0 auto' }}
                                >
                                    <option value="">Priority</option>
                                    <option value="High">High</option>
                                    <option value="Medium">Medium</option>
                                    <option value="Low">Low</option>
                                    <option value="None">None</option>
                                </select>
                                
                                {/* Date selection inputs only shown in Summary view */}
                                {viewMode === "summary" && (
                                    <>
                                        <input
                                            type="date"
                                            className="filter-select"
                                            value={startDate}
                                            onChange={(e) => setStartDate(e.target.value)}
                                            style={{ width: '145px', flex: '0 0 auto' }}
                                        />
                                        
                                        <input
                                            type="date"
                                            className="filter-select"
                                            value={endDate}
                                            onChange={(e) => setEndDate(e.target.value)}
                                            style={{ width: '145px', flex: '0 0 auto' }}
                                        />
                                    </>
                                )}
                                
                                {(filterTag || filterUser || filterStatus || filterPriority || startDate || endDate || offset !== 0) && (
                                    <button 
                                        className="header-btn" 
                                        onClick={handleResetFilters}
                                        style={{ marginLeft: 'auto', whiteSpace: 'nowrap' }}
                                    >
                                        <i className="fas fa-undo"></i> Reset
                                    </button>
                                )}
                            </div>
                            
                            {/* Week navigation controls moved to middle section */}
                            <div className="right-offset-controls" style={{ display: 'flex', justifyContent: 'center' }}>
                                {viewMode === "daily" && (
                                    <div style={{ display: 'flex', gap: '10px', alignItems: 'center' }}>
                                        <button 
                                            className="header-btn" 
                                            onClick={() => setOffset(prev => prev - 1)}
                                            title="Previous Week"
                                        >
                                            <i className="fas fa-chevron-left"></i>
                                        </button>
                                        <button 
                                            className="header-btn" 
                                            onClick={() => setOffset(0)}
                                            title="Current Week"
                                        >
                                            Today
                                        </button>
                                        <button 
                                            className="header-btn" 
                                            onClick={() => setOffset(prev => prev + 1)}
                                            title="Next Week"
                                        >
                                            <i className="fas fa-chevron-right"></i>
                                        </button>
                                    </div>
                                )}
                            </div>
                            
                            <div className="view-mode-container">
                                <div className="view-mode-toggle">
                                    <button
                                        className={`view-mode-btn ${viewMode === "daily" ? "active" : ""}`}
                                        onClick={() => setViewMode("daily")}
                                    >
                                        Daily
                                    </button>
                                    <button
                                        className={`view-mode-btn ${viewMode === "monthly" ? "active" : ""}`}
                                        onClick={() => setViewMode("monthly")}
                                    >
                                        Monthly
                                    </button>
                                    <button
                                        className={`view-mode-btn ${viewMode === "weekly" ? "active" : ""}`}
                                        onClick={() => setViewMode("weekly")}
                                    >
                                        Status
                                    </button>
                                    <button
                                        className={`view-mode-btn ${viewMode === "summary" ? "active" : ""}`}
                                        onClick={() => setViewMode("summary")}
                                    >
                                        Summary
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        {renderViewComponent()}
                        
                        {/* Floating Action Button */}
                        <div className="fab tooltip" onClick={handleQuickAddTask} data-tooltip="Add New Task">
                            <span className="fab-text">New Task</span>
                            <i className="fas fa-plus fab-icon"></i>
                        </div>
                        
                        {/* Help Modal */}
                        {showHelp && <HelpModal onClose={() => setShowHelp(false)} />}
                        
                        {/* Dexie DB Modal */}
                        {showDexie && <DexieModal tasks={dbTasks} onClose={() => setShowDexie(false)} />}
                        
                        {/* Excalidraw Modal */}
                        {showExcalidraw && <ExcalidrawModal onClose={() => setShowExcalidraw(false)} />}

                        {/* Credits Modal */}
                        {showCredits && <CreditsModal onClose={() => setShowCredits(false)} />}
                    </main>
                </div>
            );
        }
        /************************************************/
        /* 8) APP INITIALIZATION WITH PROVIDERS         */
        /************************************************/
        
        // App initialization with ThemeProvider and ToastProvider
        function AppWithProviders() {
            return (
                <ThemeProvider>
                    <ToastProvider>
                        <App />
                    </ToastProvider>
                </ThemeProvider>
            );
        }
        
        // Error Boundary Component
        class ErrorBoundary extends React.Component {
            constructor(props) {
                super(props);
                this.state = { hasError: false, error: null };
            }
            
            static getDerivedStateFromError(error) {
                return { hasError: true, error };
            }
            
            componentDidCatch(error, errorInfo) {
                console.error("Error caught by boundary:", error, errorInfo);
            }
            
            render() {
                if (this.state.hasError) {
                    return (
                        <div style={{ 
                            padding: '20px', 
                            textAlign: 'center', 
                            maxWidth: '500px', 
                            margin: '50px auto',
                            backgroundColor: '#f8d7da',
                            color: '#721c24',
                            borderRadius: '8px'
                        }}>
                            <h3>Something went wrong</h3>
                            <p>The application encountered an unexpected error.</p>
                            <p>Error: {this.state.error?.message || "Unknown error"}</p>
                            <button 
                                className="btn btn-primary" 
                                onClick={() => window.location.reload()}
                            >
                                Reload App
                            </button>
                        </div>
                    );
                }
                return this.props.children;
            }
        }
        
        /************************************************/
        /* 9) RENDER APP                                */
        /************************************************/
        
        ReactDOM.render(
            <ErrorBoundary>
                <AppWithProviders />
            </ErrorBoundary>,
            document.getElementById("root")
        );
    </script>
</body>

</html>